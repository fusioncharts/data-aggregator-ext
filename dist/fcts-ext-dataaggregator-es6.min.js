/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	const AggregatorGetter = __webpack_require__(2);
	
	;(function (env, factory) {
	  if (typeof module === 'object' && module.exports) {
	    module.exports = env.document
	       ? factory(env) : function (win) {
	         if (!win.document) {
	           throw new Error('Window with document not present');
	         }
	         return factory(win, true);
	       };
	  } else {
	    env.Aggregator = factory(env, true);
	  }
	})(typeof window !== 'undefined' ? window : this, function (_window, windowExists) {
	  var FC = _window.FusionCharts;
	
	  FC.register('extension', ['private', 'data-aggregator', function () {
	    FC.registerComponent('extensions', 'data-aggregator', AggregatorGetter({FC: FC}));
	  }]);
	});


/***/ },
/* 2 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function (dep) {
	  /**
	   * Class representing the Data Aggregator.
	   */
	  class Aggregator {
	    /**
	     * Create a Aggregator.
	     * @typedef {object} Aggregator.aggregation
	     * @property {string} timePeriod - The time interval of aggregation.
	     * @property {number} timePeriodMultiplier - The multiplier of time interval.
	     * @property {string} aggregationMethod - The method applied to aggregate.
	     */
	    constructor () {
	      /**
	       * @private
	       */
	      this.appliedAggregation = {
	        timePeriod: null,
	        timePeriodMultiplier: null,
	        aggregationMethod: null
	      };
	      this.config = {};
	    }
	
	    /**
	     * An object representing the timePeriod, timePeriodMultiplier, aggregationMethod.
	     * @type {Aggregator.aggregation}
	     */
	    get aggregation () {
	      return this.appliedAggregation;
	    }
	
	    set aggregation (obj) {
	      this.appliedAggregation.timePeriod = obj.timePeriod;
	      this.appliedAggregation.timePeriodMultiplier = obj.timePeriodMultiplier;
	      this.appliedAggregation.aggregationMethod = obj.aggregationMethod;
	    }
	
	    /**
	     * Sets available aggregation options in configuration of extension
	     * @private
	     */
	    getAvailablelAggreagation () {
	      var config = this.config,
	        dataAgg = config.dataAgg,
	        avlTimePeriods = config.avlTimePeriods = dataAgg.getAggregationTimeRules(),
	        i,
	        len;
	
	      config.avlTimeMultiplier = [];
	      len = avlTimePeriods.length;
	
	      for (i = 0; i < len; i++) {
	        config.avlTimeMultiplier.push(avlTimePeriods[i].possibleFactors);
	      }
	    }
	
	    /**
	     * Calculates valid aggregation time periods and corresponding multipliers
	     * @private
	     */
	    getValidAggregation () {
	      var self = this,
	        config = self.config,
	        tsObject = self.tsObject,
	        dataAgg = config.dataAgg,
	        i,
	        j,
	        len1,
	        len2,
	        avlTimePeriods,
	        avlTimeMultiplier,
	        // minNumOfPlot = 5,
	        maxNumOfPlot = config.composition.reactiveModel.model['max-plot-point'],
	        multipliersArr,
	        currentTimeLength,
	        timePeriod,
	        time,
	        expectedTime,
	        multiplier,
	        minBinSize;
	        // maxBinSize;
	
	      config.currentTimeLength = tsObject.globalReactiveModel.model['x-axis-visible-range-end'] -
	        tsObject.globalReactiveModel.model['x-axis-visible-range-start'];
	
	      avlTimePeriods = config.avlTimePeriods;
	      avlTimeMultiplier = config.avlTimeMultiplier;
	      currentTimeLength = config.currentTimeLength;
	
	      config.minBinSize = minBinSize = currentTimeLength / maxNumOfPlot;
	      // config.maxBinSize = maxBinSize = currentTimeLength / minNumOfPlot;
	
	      config.validTimePeriod = [];
	      config.validTimePeriodMultiplier = [];
	      config.avlAggMethods = dataAgg.getAllAggregationMethod();
	
	      for (i = 0, len1 = avlTimePeriods.length; i < len1; i++) {
	        timePeriod = avlTimePeriods[i].name;
	        time = avlTimePeriods[i].interval;
	        multipliersArr = [];
	
	        for (j = 0, len2 = avlTimeMultiplier[i].length; j < len2; j++) {
	          multiplier = avlTimeMultiplier[i][j];
	          expectedTime = multiplier * time;
	
	          // if ((expectedTime >= minBinSize) && (expectedTime <= maxBinSize)) {
	          if ((expectedTime >= minBinSize)) {
	            multipliersArr.push(avlTimeMultiplier[i][j]);
	          }
	        }
	        if (multipliersArr.length > 0) {
	          config.validTimePeriodMultiplier.push(multipliersArr);
	          config.validTimePeriod.push(timePeriod);
	        }
	      }
	      // console.log('Time Period: ', config.validTimePeriod);
	      // console.log('Number Of Multipliers: ', config.validTimePeriodMultiplier);
	      // console.log('Methods: ', config.avlAggMethods);
	    }
	
	    getCurrentAggreation () {
	      var self = this,
	        config = self.config,
	        dataAgg = config.dataAgg,
	        composition = config.composition,
	        model = composition.reactiveModel,
	        currentAggMethod,
	        suitableInterval,
	        binSize;
	
	      binSize = model.prop('bin-size') - 1;
	
	      if (isFinite(binSize)) {
	        config.canAggregate = true;
	        suitableInterval = dataAgg.timeRules.getSuitableInterval(binSize);
	        currentAggMethod = model.prop('aggregation-fn');
	      } else {
	        config.canAggregate = false;
	        suitableInterval = composition.xAxis.getScaleObj().getIntervalObj().getConfig('intervals').minor.timeUnit;
	        config.validTimePeriod = [suitableInterval.name];
	        config.validTimePeriodMultiplier = [[suitableInterval.step]];
	        config.avlAggMethods = {
	          'invalid': {
	            formalName: 'invalid',
	            nickName: 'invalid'
	          }
	        };
	        currentAggMethod = config.avlAggMethods['invalid'];
	      }
	
	      return {
	        timePeriod: suitableInterval.name,
	        timePeriodMultiplier: suitableInterval.step,
	        aggregationMethod: {
	          value: currentAggMethod.nickName,
	          text: currentAggMethod.formalName
	        }
	      };
	    }
	
	    /**
	     * Set Aggregation on time series
	     * @param  {object} obj
	     * @property {string} timePeriod - The time interval of aggregation.
	     * @property {number} timePeriodMultiplier - The multiplier of time interval.
	     * @property {string} aggregationMethod - The method applied to aggregate.
	     */
	    setAggregation (obj) {
	      var avlAggMethods,
	        validTimePeriod,
	        timePeriodIndex,
	        validTimePeriodMultiplier,
	        config = this.config;
	
	      avlAggMethods = config.avlAggMethods;
	      validTimePeriod = config.validTimePeriod;
	      validTimePeriodMultiplier = config.validTimePeriodMultiplier;
	
	      // if (avlAggMethods.includes(obj.aggregationMethod) && validTimePeriod.includes(obj.timePeriod)) {
	      //   timePeriodIndex = validTimePeriod.indexOf(obj.timePeriod);
	      //   if (validTimePeriodMultiplier[timePeriodIndex].includes(Number(obj.timePeriodMultiplier))) {
	      //     this.aggregation = obj;
	      //     console.log(this.aggregation);
	      //     return true;
	      //   } else {
	      //     console.log(this.aggregation);
	      //     return false;
	      //   }
	      // } else {
	      //   console.log(this.aggregation);
	      //   return false;
	      // }
	    }
	
	    /**
	     * Reset Applied Aggregation
	     */
	    resetAggregation () {
	
	    }
	
	    init (require) {
	      var self = this,
	        config = self.config,
	        toolboxComponent = config.toolboxComponent = {},
	        api,
	        store,
	        composition,
	        saveTo = 'tsObject',
	        requiredParams = [
	          'graphics',
	          'globalReactiveModel',
	          'chart',
	          'spaceManagerInstance',
	          'chartInstance',
	          'smartLabel',
	          function acquire () {
	            let i = 0,
	              ii = requiredParams.length - 1,
	              param = '';
	            self[saveTo] = self[saveTo] || {};
	            self.requiredParams = {};
	            for (i = 0; i < ii; ++i) {
	              param = requiredParams[i];
	              self[saveTo][param] = arguments[i];
	            }
	            // onInit(self[saveTo]);
	          }
	        ];
	      require(requiredParams);
	
	      api = self.tsObject.chartInstance.apiInstance;
	      store = api.getComponentStore();
	      config.composition = composition = store.getCanvasByIndex(0).composition;
	      config.dataAgg = composition.impl.getDataAggregator();
	
	      toolboxComponent.toolbox = dep.FC.getComponent('api', 'toolbox');
	      toolboxComponent.config = {};
	
	      self.toolbars = [];
	
	      self.measurement = {};
	
	      self.toolbars.push(self.createToolbar());
	
	      window.Aggregator = self;
	      return self;
	    }
	
	    createToolbar () {
	      var self = this,
	        group,
	        toolbar,
	        timeMulSelectMenu,
	        timePeriodSelectMenu,
	        aggMethodSelectMenu,
	        resetButton,
	        applyButton,
	        config = self.config,
	        tsObject = self.tsObject,
	        label,
	
	        toolboxComponent = config.toolboxComponent,
	        toolbox = toolboxComponent.toolbox,
	        toolboxCompConfig = toolboxComponent.config,
	        HorizontalToolbar = toolbox.HorizontalToolbar,
	        ComponentGroup = toolbox.ComponentGroup,
	        SymbolStore = toolbox.SymbolStore,
	
	        graphics = tsObject.graphics,
	        paper = graphics.paper,
	        container = graphics.container,
	        chart = tsObject.chart,
	        smartLabel = tsObject.smartLabel,
	
	        multiplierVal,
	        timeMulSelectMenuOpt = '',
	
	        dependencies = {
	          paper: paper,
	          chart: chart,
	          smartLabel: smartLabel,
	          chartContainer: container
	        },
	        apply = function (set) {
	          var model = config.composition.reactiveModel,
	            timePeriodVal = timePeriodSelectMenu.value(),
	            timePeriodMultiplierVal = timeMulSelectMenu.value(),
	            aggMethodSelectMenuVal = aggMethodSelectMenu.value(),
	            keys,
	            timeInterval,
	            canvas = config.composition.impl;
	
	          for (keys of config.avlTimePeriods) {
	            if (keys.name === timePeriodVal) {
	              timeInterval = keys.interval;
	              break;
	            }
	          }
	
	          if (set && isFinite(model.prop('bin-size'))) {
	            model
	              .lock()
	              .prop('bin-size-ext', (timeInterval * Number(timePeriodMultiplierVal)))
	              .prop('aggregation-fn-ext', config.avlAggMethods[aggMethodSelectMenuVal])
	              .unlock();
	          } else {
	            canvas.resetAggregation();
	          }
	          // applyButton.updateVisual('disable');
	          // applyButton.updateVisual('enable');
	        },
	
	        timePeriodOnChange = function () {
	          var timePeriodVal = timePeriodSelectMenu.value(),
	            timePeriodMultiplierVal = timeMulSelectMenu.value(),
	            prevTimePeroidMulVal = timePeriodMultiplierVal,
	            validTimePeriod = config.validTimePeriod,
	            validTimePeriodMultiplier = config.validTimePeriodMultiplier,
	            indexOfTimeUnit,
	            indexOfTimeMul;
	
	          indexOfTimeUnit = validTimePeriod.indexOf(timePeriodVal);
	          indexOfTimeMul = validTimePeriodMultiplier[indexOfTimeUnit].indexOf(Number(timePeriodMultiplierVal));
	
	          // console.log(indexOfTimeUnit, indexOfTimeMul);
	          timeMulSelectMenuOpt = '';
	          for (multiplierVal of validTimePeriodMultiplier[indexOfTimeUnit]) {
	            timeMulSelectMenuOpt += '<option value="' + multiplierVal + '">' + multiplierVal + '</option>';
	          }
	
	          timeMulSelectMenu.updateList(timeMulSelectMenuOpt);
	
	          if (indexOfTimeMul < 0) {
	            timeMulSelectMenu.value(validTimePeriodMultiplier[indexOfTimeUnit][0].toString());
	          } else {
	            timeMulSelectMenu.value(prevTimePeroidMulVal);
	          }
	        };
	
	      group = new ComponentGroup(dependencies);
	      toolbar = new HorizontalToolbar(dependencies);
	
	      group.setConfig({
	        fill: '#fff',
	        borderThickness: 0
	      });
	
	      toolbar.setConfig({
	        fill: '#fff',
	        borderThickness: 0
	      });
	
	      label = new toolbox.Label('Aggregate Data:', dependencies, {
	        text: {
	          style: {
	            'font-size': '14',
	            'fill': '#696969'
	          }
	        }
	      });
	
	      toolboxCompConfig.timePeriodSelectMenu = timePeriodSelectMenu = new toolbox.SelectSymbol({
	        width: 90,
	        height: 20
	      }, dependencies, {
	        innerHTML: '<option value="time">Time Period</option>'
	      }, {
	        strokeWidth: 1,
	        stroke: 'rgba(102,102,102,0.5)',
	        symbolStrokeWidth: 0,
	        btnTextStyle: {
	          fontSize: 11
	        },
	        hoverFill: '#1e1f1f'
	      });
	
	      toolboxCompConfig.timeMulSelectMenu = timeMulSelectMenu = new toolbox.SelectSymbol({
	        width: 50,
	        height: 20
	      }, dependencies, {
	        innerHTML: '<option value="number">Multiplier</option>'
	      }, {
	        strokeWidth: 1,
	        stroke: 'rgba(102,102,102,0.5)',
	        symbolStrokeWidth: 0,
	        btnTextStyle: {
	          fontSize: 11
	        },
	        hoverFill: '#1e1f1f'
	      });
	
	      toolboxCompConfig.aggMethodSelectMenu = aggMethodSelectMenu = new toolbox.SelectSymbol({
	        width: 90,
	        height: 20
	      }, dependencies, {
	        innerHTML: '<option value="Formula">Method</option>'
	      }, {
	        strokeWidth: 1,
	        stroke: 'rgba(102,102,102,0.5)',
	        symbolStrokeWidth: 0,
	        btnTextStyle: {
	          fontSize: 11
	        },
	        hoverFill: '#1e1f1f'
	      });
	
	      toolboxCompConfig.applyButton = applyButton = new toolbox.Symbol('APPLY', true, dependencies, {
	        fill: '#555',
	        labelFill: '#fff',
	        hoverFill: '#555',
	        width: 30,
	        height: 20,
	        btnTextStyle: {
	          fontSize: 11
	        }
	      }).attachEventHandlers({
	        click: function () {
	          apply(1);
	        }
	      });
	      toolboxCompConfig.resetButton = resetButton = new toolbox.Symbol('RESET', true, dependencies, {
	        fill: '#898b8b',
	        labelFill: '#fff',
	        hoverFill: '#898b8b',
	        width: 30,
	        height: 20,
	        btnTextStyle: {
	          fontSize: 11
	        }
	      }).attachEventHandlers({
	        click: function () {
	          apply(0);
	        }
	      });
	
	      group.addSymbol(label);
	      group.addSymbol(timeMulSelectMenu);
	      group.addSymbol(timePeriodSelectMenu);
	      group.addSymbol(aggMethodSelectMenu);
	      group.addSymbol(applyButton);
	      group.addSymbol(resetButton);
	
	      SymbolStore.register('textBoxIcon', function (x, y, rad, w, h, padX, padY) {
	        var x1 = x - w / 2 + padX / 2,
	          x2 = x + w / 2 - padX / 2,
	          y1 = y - h / 2 + padY / 2,
	          y2 = y + h / 2 - padY / 2;
	
	        return ['M', x1, y1, 'L', x2, y1, 'L', x2, y2, 'L', x1, y2, 'Z'];
	      });
	
	      timeMulSelectMenu.attachEventHandlers({
	        click: {
	          fn: timeMulSelectMenu.edit
	        },
	        textOnBlur: function () {
	          timeMulSelectMenu.blur();
	        }
	      });
	      timePeriodSelectMenu.attachEventHandlers({
	        click: {
	          fn: timePeriodSelectMenu.edit
	        },
	        textOnBlur: function () {
	          timePeriodSelectMenu.blur();
	        },
	        textOnChange: function () {
	          timePeriodSelectMenu.blur();
	          timePeriodOnChange();
	        }
	      });
	      aggMethodSelectMenu.attachEventHandlers({
	        click: {
	          fn: aggMethodSelectMenu.edit
	        },
	        textOnBlur: function () {
	          aggMethodSelectMenu.blur();
	        }
	      });
	
	      toolbar.addComponent(group);
	
	      return toolbar;
	    }
	
	    getLogicalSpace (availableWidth, availableHeight) {
	      var logicalSpace,
	        width = 0,
	        height = 0,
	        i,
	        ln;
	
	      for (i = 0, ln = this.toolbars.length; i < ln; i++) {
	        logicalSpace = this.toolbars[i].getLogicalSpace();
	        width = Math.max(logicalSpace.width, width);
	        height += logicalSpace.height;
	        this.toolbars[i].width = logicalSpace.width;
	        this.toolbars[i].height = logicalSpace.height;
	      }
	      height += this.padding;
	      return {
	        width: width > availableWidth ? 0 : width,
	        height: height > availableHeight ? 0 : height
	      };
	    }
	
	    placeInCanvas (containerInstance) {
	      var self = this,
	        tsObject = self.tsObject;
	
	      self.padding = 5;
	      tsObject.spaceManagerInstance.add([{
	        name: function () {
	          return 'DataAggregator';
	        },
	        ref: function (obj) {
	          return obj['0'];
	        },
	        self: function () {
	          return self;
	        },
	        priority: function () {
	          return 2;
	        },
	        layout: function (obj) {
	          return obj.inline;
	        },
	        orientation: [{
	          type: function (obj) {
	            return obj.horizontal;
	          },
	          position: [{
	            type: function (obj) {
	              return obj.top;
	            },
	            alignment: [{
	              type: function (obj) {
	                return obj.left;
	              },
	              dimensions: [function () {
	                var parent = this.getParentComponentGroup();
	                return self.getLogicalSpace(parent.getWidth(), parent.getHeight());
	              }]
	            }]
	          }]
	        }]
	      }]);
	    }
	
	    setDrawingConfiguration (x, y, width, height, group) {
	      var mes = this.measurement;
	      mes.x = x;
	      mes.y = y;
	      mes.width = width;
	      mes.height = height;
	
	      this.parentGroup = group;
	
	      return this;
	    }
	
	    draw (x, y, width, height, group) {
	      var self = this,
	        config = self.config,
	        toolboxCompConfig = config.toolboxComponent.config,
	        timePeriodSelectMenu = toolboxCompConfig.timePeriodSelectMenu,
	        timeMulSelectMenu = toolboxCompConfig.timeMulSelectMenu,
	        aggMethodSelectMenu = toolboxCompConfig.aggMethodSelectMenu,
	        currentAggregationObj,
	        measurement = self.measurement,
	        toolbars = self.toolbars,
	        ln,
	        i,
	        toolbar,
	        model = config.composition.reactiveModel,
	
	        timePeriodVal,
	        timePeriodSelectMenuOpt,
	        validTimePeriod,
	        indexOfTimeUnit,
	
	        multiplierVal,
	        timeMulSelectMenuOpt,
	        validTimePeriodMultiplier,
	
	        aggVal,
	        aggMethodSelectMenuOpt,
	        avlAggMethods,
	        rangeOnChange = function () {
	          var attrStr = '';
	
	          self.getValidAggregation();
	          currentAggregationObj = self.getCurrentAggreation();
	
	          timePeriodSelectMenuOpt = '';
	          timeMulSelectMenuOpt = '';
	          aggMethodSelectMenuOpt = '';
	
	          validTimePeriod = config.validTimePeriod;
	          validTimePeriodMultiplier = config.validTimePeriodMultiplier;
	          avlAggMethods = config.avlAggMethods;
	
	          if (!config.canAggregate) {
	            attrStr = 'disabled hidden';
	          }
	
	          for (timePeriodVal of validTimePeriod) {
	            timePeriodSelectMenuOpt += '<option ' + attrStr + ' value="' + timePeriodVal + '">' +
	            timePeriodVal.toUpperCase() + '</option>';
	          }
	
	          timePeriodSelectMenu.updateList(timePeriodSelectMenuOpt);
	          timePeriodSelectMenu.value(currentAggregationObj.timePeriod);
	
	          indexOfTimeUnit = validTimePeriod.indexOf(currentAggregationObj.timePeriod);
	
	          if (indexOfTimeUnit >= 0) {
	            for (multiplierVal of validTimePeriodMultiplier[indexOfTimeUnit]) {
	              timeMulSelectMenuOpt += '<option ' + attrStr + ' value="' + multiplierVal + '">' +
	              multiplierVal.toString().toUpperCase() + '</option>';
	            }
	          }
	
	          timeMulSelectMenu.updateList(timeMulSelectMenuOpt);
	          timeMulSelectMenu.value(currentAggregationObj.timePeriodMultiplier.toString());
	
	          for (aggVal in avlAggMethods) {
	            aggMethodSelectMenuOpt += '<option ' + attrStr + ' value="' +
	              avlAggMethods[aggVal].nickName + '">' + avlAggMethods[aggVal].formalName.toUpperCase() + '</option>';
	          }
	
	          aggMethodSelectMenu.updateList(aggMethodSelectMenuOpt);
	          aggMethodSelectMenu.value(currentAggregationObj.aggregationMethod.value);
	        };
	
	      self.getAvailablelAggreagation();
	
	      x = x === undefined ? measurement.x : x;
	      y = y === undefined ? measurement.y : y;
	      width = width === undefined ? measurement.width : width;
	      height = height === undefined ? measurement.height : height;
	      group = group === undefined ? self.parentGroup : group;
	      if (width && height) {
	        for (i = 0, ln = toolbars.length; i < ln; i++) {
	          toolbar = toolbars[i];
	          toolbar.draw(x, y);
	        }
	      }
	      rangeOnChange();
	
	      model.onPropsChange(['bin-size', 'aggregation-fn'], rangeOnChange);
	    }
	
	    dispose () {
	      // dispose extension
	    }
	  }
	  return Aggregator;
	};


/***/ }
/******/ ]);

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNDljNjRkYzEyZGM0YmMyMWFmMTUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9mY3RzLWV4dC1hZ2dyZWdhdG9yLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3RDQTtBQUNBOztBQUVBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7O0FBRUE7QUFDQSw2RUFBNEUsT0FBTztBQUNuRixJQUFHO0FBQ0gsRUFBQzs7Ozs7OztBQ3JCRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixPQUFPO0FBQ3hCLG1CQUFrQixPQUFPO0FBQ3pCLG1CQUFrQixPQUFPO0FBQ3pCLG1CQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0RBQStDLFVBQVU7QUFDekQ7QUFDQTtBQUNBOztBQUVBLHdEQUF1RCxVQUFVO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkIsbUJBQWtCLE9BQU87QUFDekIsbUJBQWtCLE9BQU87QUFDekIsbUJBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0RBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxRQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQU87O0FBRVA7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxnQkFBZTtBQUNmLGNBQWE7QUFDYixZQUFXO0FBQ1gsVUFBUztBQUNULFFBQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJmY3RzLWV4dC1kYXRhYWdncmVnYXRvci1lczYubWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGlkOiBtb2R1bGVJZCxcbiBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgNDljNjRkYzEyZGM0YmMyMWFmMTUiLCIndXNlIHN0cmljdCc7XG5jb25zdCBBZ2dyZWdhdG9yR2V0dGVyID0gcmVxdWlyZSgnLi9mY3RzLWV4dC1hZ2dyZWdhdG9yJyk7XG5cbjsoZnVuY3Rpb24gKGVudiwgZmFjdG9yeSkge1xuICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGVudi5kb2N1bWVudFxuICAgICAgID8gZmFjdG9yeShlbnYpIDogZnVuY3Rpb24gKHdpbikge1xuICAgICAgICAgaWYgKCF3aW4uZG9jdW1lbnQpIHtcbiAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXaW5kb3cgd2l0aCBkb2N1bWVudCBub3QgcHJlc2VudCcpO1xuICAgICAgICAgfVxuICAgICAgICAgcmV0dXJuIGZhY3Rvcnkod2luLCB0cnVlKTtcbiAgICAgICB9O1xuICB9IGVsc2Uge1xuICAgIGVudi5BZ2dyZWdhdG9yID0gZmFjdG9yeShlbnYsIHRydWUpO1xuICB9XG59KSh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uIChfd2luZG93LCB3aW5kb3dFeGlzdHMpIHtcbiAgdmFyIEZDID0gX3dpbmRvdy5GdXNpb25DaGFydHM7XG5cbiAgRkMucmVnaXN0ZXIoJ2V4dGVuc2lvbicsIFsncHJpdmF0ZScsICdkYXRhLWFnZ3JlZ2F0b3InLCBmdW5jdGlvbiAoKSB7XG4gICAgRkMucmVnaXN0ZXJDb21wb25lbnQoJ2V4dGVuc2lvbnMnLCAnZGF0YS1hZ2dyZWdhdG9yJywgQWdncmVnYXRvckdldHRlcih7RkM6IEZDfSkpO1xuICB9XSk7XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZGVwKSB7XG4gIC8qKlxuICAgKiBDbGFzcyByZXByZXNlbnRpbmcgdGhlIERhdGEgQWdncmVnYXRvci5cbiAgICovXG4gIGNsYXNzIEFnZ3JlZ2F0b3Ige1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIEFnZ3JlZ2F0b3IuXG4gICAgICogQHR5cGVkZWYge29iamVjdH0gQWdncmVnYXRvci5hZ2dyZWdhdGlvblxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0aW1lUGVyaW9kIC0gVGhlIHRpbWUgaW50ZXJ2YWwgb2YgYWdncmVnYXRpb24uXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHRpbWVQZXJpb2RNdWx0aXBsaWVyIC0gVGhlIG11bHRpcGxpZXIgb2YgdGltZSBpbnRlcnZhbC5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gYWdncmVnYXRpb25NZXRob2QgLSBUaGUgbWV0aG9kIGFwcGxpZWQgdG8gYWdncmVnYXRlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yICgpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuICAgICAgdGhpcy5hcHBsaWVkQWdncmVnYXRpb24gPSB7XG4gICAgICAgIHRpbWVQZXJpb2Q6IG51bGwsXG4gICAgICAgIHRpbWVQZXJpb2RNdWx0aXBsaWVyOiBudWxsLFxuICAgICAgICBhZ2dyZWdhdGlvbk1ldGhvZDogbnVsbFxuICAgICAgfTtcbiAgICAgIHRoaXMuY29uZmlnID0ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgdGltZVBlcmlvZCwgdGltZVBlcmlvZE11bHRpcGxpZXIsIGFnZ3JlZ2F0aW9uTWV0aG9kLlxuICAgICAqIEB0eXBlIHtBZ2dyZWdhdG9yLmFnZ3JlZ2F0aW9ufVxuICAgICAqL1xuICAgIGdldCBhZ2dyZWdhdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5hcHBsaWVkQWdncmVnYXRpb247XG4gICAgfVxuXG4gICAgc2V0IGFnZ3JlZ2F0aW9uIChvYmopIHtcbiAgICAgIHRoaXMuYXBwbGllZEFnZ3JlZ2F0aW9uLnRpbWVQZXJpb2QgPSBvYmoudGltZVBlcmlvZDtcbiAgICAgIHRoaXMuYXBwbGllZEFnZ3JlZ2F0aW9uLnRpbWVQZXJpb2RNdWx0aXBsaWVyID0gb2JqLnRpbWVQZXJpb2RNdWx0aXBsaWVyO1xuICAgICAgdGhpcy5hcHBsaWVkQWdncmVnYXRpb24uYWdncmVnYXRpb25NZXRob2QgPSBvYmouYWdncmVnYXRpb25NZXRob2Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBhdmFpbGFibGUgYWdncmVnYXRpb24gb3B0aW9ucyBpbiBjb25maWd1cmF0aW9uIG9mIGV4dGVuc2lvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0QXZhaWxhYmxlbEFnZ3JlYWdhdGlvbiAoKSB7XG4gICAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWcsXG4gICAgICAgIGRhdGFBZ2cgPSBjb25maWcuZGF0YUFnZyxcbiAgICAgICAgYXZsVGltZVBlcmlvZHMgPSBjb25maWcuYXZsVGltZVBlcmlvZHMgPSBkYXRhQWdnLmdldEFnZ3JlZ2F0aW9uVGltZVJ1bGVzKCksXG4gICAgICAgIGksXG4gICAgICAgIGxlbjtcblxuICAgICAgY29uZmlnLmF2bFRpbWVNdWx0aXBsaWVyID0gW107XG4gICAgICBsZW4gPSBhdmxUaW1lUGVyaW9kcy5sZW5ndGg7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25maWcuYXZsVGltZU11bHRpcGxpZXIucHVzaChhdmxUaW1lUGVyaW9kc1tpXS5wb3NzaWJsZUZhY3RvcnMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdmFsaWQgYWdncmVnYXRpb24gdGltZSBwZXJpb2RzIGFuZCBjb3JyZXNwb25kaW5nIG11bHRpcGxpZXJzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRWYWxpZEFnZ3JlZ2F0aW9uICgpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgY29uZmlnID0gc2VsZi5jb25maWcsXG4gICAgICAgIHRzT2JqZWN0ID0gc2VsZi50c09iamVjdCxcbiAgICAgICAgZGF0YUFnZyA9IGNvbmZpZy5kYXRhQWdnLFxuICAgICAgICBpLFxuICAgICAgICBqLFxuICAgICAgICBsZW4xLFxuICAgICAgICBsZW4yLFxuICAgICAgICBhdmxUaW1lUGVyaW9kcyxcbiAgICAgICAgYXZsVGltZU11bHRpcGxpZXIsXG4gICAgICAgIC8vIG1pbk51bU9mUGxvdCA9IDUsXG4gICAgICAgIG1heE51bU9mUGxvdCA9IGNvbmZpZy5jb21wb3NpdGlvbi5yZWFjdGl2ZU1vZGVsLm1vZGVsWydtYXgtcGxvdC1wb2ludCddLFxuICAgICAgICBtdWx0aXBsaWVyc0FycixcbiAgICAgICAgY3VycmVudFRpbWVMZW5ndGgsXG4gICAgICAgIHRpbWVQZXJpb2QsXG4gICAgICAgIHRpbWUsXG4gICAgICAgIGV4cGVjdGVkVGltZSxcbiAgICAgICAgbXVsdGlwbGllcixcbiAgICAgICAgbWluQmluU2l6ZTtcbiAgICAgICAgLy8gbWF4QmluU2l6ZTtcblxuICAgICAgY29uZmlnLmN1cnJlbnRUaW1lTGVuZ3RoID0gdHNPYmplY3QuZ2xvYmFsUmVhY3RpdmVNb2RlbC5tb2RlbFsneC1heGlzLXZpc2libGUtcmFuZ2UtZW5kJ10gLVxuICAgICAgICB0c09iamVjdC5nbG9iYWxSZWFjdGl2ZU1vZGVsLm1vZGVsWyd4LWF4aXMtdmlzaWJsZS1yYW5nZS1zdGFydCddO1xuXG4gICAgICBhdmxUaW1lUGVyaW9kcyA9IGNvbmZpZy5hdmxUaW1lUGVyaW9kcztcbiAgICAgIGF2bFRpbWVNdWx0aXBsaWVyID0gY29uZmlnLmF2bFRpbWVNdWx0aXBsaWVyO1xuICAgICAgY3VycmVudFRpbWVMZW5ndGggPSBjb25maWcuY3VycmVudFRpbWVMZW5ndGg7XG5cbiAgICAgIGNvbmZpZy5taW5CaW5TaXplID0gbWluQmluU2l6ZSA9IGN1cnJlbnRUaW1lTGVuZ3RoIC8gbWF4TnVtT2ZQbG90O1xuICAgICAgLy8gY29uZmlnLm1heEJpblNpemUgPSBtYXhCaW5TaXplID0gY3VycmVudFRpbWVMZW5ndGggLyBtaW5OdW1PZlBsb3Q7XG5cbiAgICAgIGNvbmZpZy52YWxpZFRpbWVQZXJpb2QgPSBbXTtcbiAgICAgIGNvbmZpZy52YWxpZFRpbWVQZXJpb2RNdWx0aXBsaWVyID0gW107XG4gICAgICBjb25maWcuYXZsQWdnTWV0aG9kcyA9IGRhdGFBZ2cuZ2V0QWxsQWdncmVnYXRpb25NZXRob2QoKTtcblxuICAgICAgZm9yIChpID0gMCwgbGVuMSA9IGF2bFRpbWVQZXJpb2RzLmxlbmd0aDsgaSA8IGxlbjE7IGkrKykge1xuICAgICAgICB0aW1lUGVyaW9kID0gYXZsVGltZVBlcmlvZHNbaV0ubmFtZTtcbiAgICAgICAgdGltZSA9IGF2bFRpbWVQZXJpb2RzW2ldLmludGVydmFsO1xuICAgICAgICBtdWx0aXBsaWVyc0FyciA9IFtdO1xuXG4gICAgICAgIGZvciAoaiA9IDAsIGxlbjIgPSBhdmxUaW1lTXVsdGlwbGllcltpXS5sZW5ndGg7IGogPCBsZW4yOyBqKyspIHtcbiAgICAgICAgICBtdWx0aXBsaWVyID0gYXZsVGltZU11bHRpcGxpZXJbaV1bal07XG4gICAgICAgICAgZXhwZWN0ZWRUaW1lID0gbXVsdGlwbGllciAqIHRpbWU7XG5cbiAgICAgICAgICAvLyBpZiAoKGV4cGVjdGVkVGltZSA+PSBtaW5CaW5TaXplKSAmJiAoZXhwZWN0ZWRUaW1lIDw9IG1heEJpblNpemUpKSB7XG4gICAgICAgICAgaWYgKChleHBlY3RlZFRpbWUgPj0gbWluQmluU2l6ZSkpIHtcbiAgICAgICAgICAgIG11bHRpcGxpZXJzQXJyLnB1c2goYXZsVGltZU11bHRpcGxpZXJbaV1bal0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobXVsdGlwbGllcnNBcnIubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbmZpZy52YWxpZFRpbWVQZXJpb2RNdWx0aXBsaWVyLnB1c2gobXVsdGlwbGllcnNBcnIpO1xuICAgICAgICAgIGNvbmZpZy52YWxpZFRpbWVQZXJpb2QucHVzaCh0aW1lUGVyaW9kKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gY29uc29sZS5sb2coJ1RpbWUgUGVyaW9kOiAnLCBjb25maWcudmFsaWRUaW1lUGVyaW9kKTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdOdW1iZXIgT2YgTXVsdGlwbGllcnM6ICcsIGNvbmZpZy52YWxpZFRpbWVQZXJpb2RNdWx0aXBsaWVyKTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdNZXRob2RzOiAnLCBjb25maWcuYXZsQWdnTWV0aG9kcyk7XG4gICAgfVxuXG4gICAgZ2V0Q3VycmVudEFnZ3JlYXRpb24gKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBjb25maWcgPSBzZWxmLmNvbmZpZyxcbiAgICAgICAgZGF0YUFnZyA9IGNvbmZpZy5kYXRhQWdnLFxuICAgICAgICBjb21wb3NpdGlvbiA9IGNvbmZpZy5jb21wb3NpdGlvbixcbiAgICAgICAgbW9kZWwgPSBjb21wb3NpdGlvbi5yZWFjdGl2ZU1vZGVsLFxuICAgICAgICBjdXJyZW50QWdnTWV0aG9kLFxuICAgICAgICBzdWl0YWJsZUludGVydmFsLFxuICAgICAgICBiaW5TaXplO1xuXG4gICAgICBiaW5TaXplID0gbW9kZWwucHJvcCgnYmluLXNpemUnKSAtIDE7XG5cbiAgICAgIGlmIChpc0Zpbml0ZShiaW5TaXplKSkge1xuICAgICAgICBjb25maWcuY2FuQWdncmVnYXRlID0gdHJ1ZTtcbiAgICAgICAgc3VpdGFibGVJbnRlcnZhbCA9IGRhdGFBZ2cudGltZVJ1bGVzLmdldFN1aXRhYmxlSW50ZXJ2YWwoYmluU2l6ZSk7XG4gICAgICAgIGN1cnJlbnRBZ2dNZXRob2QgPSBtb2RlbC5wcm9wKCdhZ2dyZWdhdGlvbi1mbicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uZmlnLmNhbkFnZ3JlZ2F0ZSA9IGZhbHNlO1xuICAgICAgICBzdWl0YWJsZUludGVydmFsID0gY29tcG9zaXRpb24ueEF4aXMuZ2V0U2NhbGVPYmooKS5nZXRJbnRlcnZhbE9iaigpLmdldENvbmZpZygnaW50ZXJ2YWxzJykubWlub3IudGltZVVuaXQ7XG4gICAgICAgIGNvbmZpZy52YWxpZFRpbWVQZXJpb2QgPSBbc3VpdGFibGVJbnRlcnZhbC5uYW1lXTtcbiAgICAgICAgY29uZmlnLnZhbGlkVGltZVBlcmlvZE11bHRpcGxpZXIgPSBbW3N1aXRhYmxlSW50ZXJ2YWwuc3RlcF1dO1xuICAgICAgICBjb25maWcuYXZsQWdnTWV0aG9kcyA9IHtcbiAgICAgICAgICAnaW52YWxpZCc6IHtcbiAgICAgICAgICAgIGZvcm1hbE5hbWU6ICdpbnZhbGlkJyxcbiAgICAgICAgICAgIG5pY2tOYW1lOiAnaW52YWxpZCdcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGN1cnJlbnRBZ2dNZXRob2QgPSBjb25maWcuYXZsQWdnTWV0aG9kc1snaW52YWxpZCddO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0aW1lUGVyaW9kOiBzdWl0YWJsZUludGVydmFsLm5hbWUsXG4gICAgICAgIHRpbWVQZXJpb2RNdWx0aXBsaWVyOiBzdWl0YWJsZUludGVydmFsLnN0ZXAsXG4gICAgICAgIGFnZ3JlZ2F0aW9uTWV0aG9kOiB7XG4gICAgICAgICAgdmFsdWU6IGN1cnJlbnRBZ2dNZXRob2Qubmlja05hbWUsXG4gICAgICAgICAgdGV4dDogY3VycmVudEFnZ01ldGhvZC5mb3JtYWxOYW1lXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IEFnZ3JlZ2F0aW9uIG9uIHRpbWUgc2VyaWVzXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBvYmpcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gdGltZVBlcmlvZCAtIFRoZSB0aW1lIGludGVydmFsIG9mIGFnZ3JlZ2F0aW9uLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lUGVyaW9kTXVsdGlwbGllciAtIFRoZSBtdWx0aXBsaWVyIG9mIHRpbWUgaW50ZXJ2YWwuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IGFnZ3JlZ2F0aW9uTWV0aG9kIC0gVGhlIG1ldGhvZCBhcHBsaWVkIHRvIGFnZ3JlZ2F0ZS5cbiAgICAgKi9cbiAgICBzZXRBZ2dyZWdhdGlvbiAob2JqKSB7XG4gICAgICB2YXIgYXZsQWdnTWV0aG9kcyxcbiAgICAgICAgdmFsaWRUaW1lUGVyaW9kLFxuICAgICAgICB0aW1lUGVyaW9kSW5kZXgsXG4gICAgICAgIHZhbGlkVGltZVBlcmlvZE11bHRpcGxpZXIsXG4gICAgICAgIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuXG4gICAgICBhdmxBZ2dNZXRob2RzID0gY29uZmlnLmF2bEFnZ01ldGhvZHM7XG4gICAgICB2YWxpZFRpbWVQZXJpb2QgPSBjb25maWcudmFsaWRUaW1lUGVyaW9kO1xuICAgICAgdmFsaWRUaW1lUGVyaW9kTXVsdGlwbGllciA9IGNvbmZpZy52YWxpZFRpbWVQZXJpb2RNdWx0aXBsaWVyO1xuXG4gICAgICAvLyBpZiAoYXZsQWdnTWV0aG9kcy5pbmNsdWRlcyhvYmouYWdncmVnYXRpb25NZXRob2QpICYmIHZhbGlkVGltZVBlcmlvZC5pbmNsdWRlcyhvYmoudGltZVBlcmlvZCkpIHtcbiAgICAgIC8vICAgdGltZVBlcmlvZEluZGV4ID0gdmFsaWRUaW1lUGVyaW9kLmluZGV4T2Yob2JqLnRpbWVQZXJpb2QpO1xuICAgICAgLy8gICBpZiAodmFsaWRUaW1lUGVyaW9kTXVsdGlwbGllclt0aW1lUGVyaW9kSW5kZXhdLmluY2x1ZGVzKE51bWJlcihvYmoudGltZVBlcmlvZE11bHRpcGxpZXIpKSkge1xuICAgICAgLy8gICAgIHRoaXMuYWdncmVnYXRpb24gPSBvYmo7XG4gICAgICAvLyAgICAgY29uc29sZS5sb2codGhpcy5hZ2dyZWdhdGlvbik7XG4gICAgICAvLyAgICAgcmV0dXJuIHRydWU7XG4gICAgICAvLyAgIH0gZWxzZSB7XG4gICAgICAvLyAgICAgY29uc29sZS5sb2codGhpcy5hZ2dyZWdhdGlvbik7XG4gICAgICAvLyAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gICB9XG4gICAgICAvLyB9IGVsc2Uge1xuICAgICAgLy8gICBjb25zb2xlLmxvZyh0aGlzLmFnZ3JlZ2F0aW9uKTtcbiAgICAgIC8vICAgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2V0IEFwcGxpZWQgQWdncmVnYXRpb25cbiAgICAgKi9cbiAgICByZXNldEFnZ3JlZ2F0aW9uICgpIHtcblxuICAgIH1cblxuICAgIGluaXQgKHJlcXVpcmUpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgY29uZmlnID0gc2VsZi5jb25maWcsXG4gICAgICAgIHRvb2xib3hDb21wb25lbnQgPSBjb25maWcudG9vbGJveENvbXBvbmVudCA9IHt9LFxuICAgICAgICBhcGksXG4gICAgICAgIHN0b3JlLFxuICAgICAgICBjb21wb3NpdGlvbixcbiAgICAgICAgc2F2ZVRvID0gJ3RzT2JqZWN0JyxcbiAgICAgICAgcmVxdWlyZWRQYXJhbXMgPSBbXG4gICAgICAgICAgJ2dyYXBoaWNzJyxcbiAgICAgICAgICAnZ2xvYmFsUmVhY3RpdmVNb2RlbCcsXG4gICAgICAgICAgJ2NoYXJ0JyxcbiAgICAgICAgICAnc3BhY2VNYW5hZ2VySW5zdGFuY2UnLFxuICAgICAgICAgICdjaGFydEluc3RhbmNlJyxcbiAgICAgICAgICAnc21hcnRMYWJlbCcsXG4gICAgICAgICAgZnVuY3Rpb24gYWNxdWlyZSAoKSB7XG4gICAgICAgICAgICBsZXQgaSA9IDAsXG4gICAgICAgICAgICAgIGlpID0gcmVxdWlyZWRQYXJhbXMubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgICAgcGFyYW0gPSAnJztcbiAgICAgICAgICAgIHNlbGZbc2F2ZVRvXSA9IHNlbGZbc2F2ZVRvXSB8fCB7fTtcbiAgICAgICAgICAgIHNlbGYucmVxdWlyZWRQYXJhbXMgPSB7fTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICAgIHBhcmFtID0gcmVxdWlyZWRQYXJhbXNbaV07XG4gICAgICAgICAgICAgIHNlbGZbc2F2ZVRvXVtwYXJhbV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBvbkluaXQoc2VsZltzYXZlVG9dKTtcbiAgICAgICAgICB9XG4gICAgICAgIF07XG4gICAgICByZXF1aXJlKHJlcXVpcmVkUGFyYW1zKTtcblxuICAgICAgYXBpID0gc2VsZi50c09iamVjdC5jaGFydEluc3RhbmNlLmFwaUluc3RhbmNlO1xuICAgICAgc3RvcmUgPSBhcGkuZ2V0Q29tcG9uZW50U3RvcmUoKTtcbiAgICAgIGNvbmZpZy5jb21wb3NpdGlvbiA9IGNvbXBvc2l0aW9uID0gc3RvcmUuZ2V0Q2FudmFzQnlJbmRleCgwKS5jb21wb3NpdGlvbjtcbiAgICAgIGNvbmZpZy5kYXRhQWdnID0gY29tcG9zaXRpb24uaW1wbC5nZXREYXRhQWdncmVnYXRvcigpO1xuXG4gICAgICB0b29sYm94Q29tcG9uZW50LnRvb2xib3ggPSBkZXAuRkMuZ2V0Q29tcG9uZW50KCdhcGknLCAndG9vbGJveCcpO1xuICAgICAgdG9vbGJveENvbXBvbmVudC5jb25maWcgPSB7fTtcblxuICAgICAgc2VsZi50b29sYmFycyA9IFtdO1xuXG4gICAgICBzZWxmLm1lYXN1cmVtZW50ID0ge307XG5cbiAgICAgIHNlbGYudG9vbGJhcnMucHVzaChzZWxmLmNyZWF0ZVRvb2xiYXIoKSk7XG5cbiAgICAgIHdpbmRvdy5BZ2dyZWdhdG9yID0gc2VsZjtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cblxuICAgIGNyZWF0ZVRvb2xiYXIgKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBncm91cCxcbiAgICAgICAgdG9vbGJhcixcbiAgICAgICAgdGltZU11bFNlbGVjdE1lbnUsXG4gICAgICAgIHRpbWVQZXJpb2RTZWxlY3RNZW51LFxuICAgICAgICBhZ2dNZXRob2RTZWxlY3RNZW51LFxuICAgICAgICByZXNldEJ1dHRvbixcbiAgICAgICAgYXBwbHlCdXR0b24sXG4gICAgICAgIGNvbmZpZyA9IHNlbGYuY29uZmlnLFxuICAgICAgICB0c09iamVjdCA9IHNlbGYudHNPYmplY3QsXG4gICAgICAgIGxhYmVsLFxuXG4gICAgICAgIHRvb2xib3hDb21wb25lbnQgPSBjb25maWcudG9vbGJveENvbXBvbmVudCxcbiAgICAgICAgdG9vbGJveCA9IHRvb2xib3hDb21wb25lbnQudG9vbGJveCxcbiAgICAgICAgdG9vbGJveENvbXBDb25maWcgPSB0b29sYm94Q29tcG9uZW50LmNvbmZpZyxcbiAgICAgICAgSG9yaXpvbnRhbFRvb2xiYXIgPSB0b29sYm94Lkhvcml6b250YWxUb29sYmFyLFxuICAgICAgICBDb21wb25lbnRHcm91cCA9IHRvb2xib3guQ29tcG9uZW50R3JvdXAsXG4gICAgICAgIFN5bWJvbFN0b3JlID0gdG9vbGJveC5TeW1ib2xTdG9yZSxcblxuICAgICAgICBncmFwaGljcyA9IHRzT2JqZWN0LmdyYXBoaWNzLFxuICAgICAgICBwYXBlciA9IGdyYXBoaWNzLnBhcGVyLFxuICAgICAgICBjb250YWluZXIgPSBncmFwaGljcy5jb250YWluZXIsXG4gICAgICAgIGNoYXJ0ID0gdHNPYmplY3QuY2hhcnQsXG4gICAgICAgIHNtYXJ0TGFiZWwgPSB0c09iamVjdC5zbWFydExhYmVsLFxuXG4gICAgICAgIG11bHRpcGxpZXJWYWwsXG4gICAgICAgIHRpbWVNdWxTZWxlY3RNZW51T3B0ID0gJycsXG5cbiAgICAgICAgZGVwZW5kZW5jaWVzID0ge1xuICAgICAgICAgIHBhcGVyOiBwYXBlcixcbiAgICAgICAgICBjaGFydDogY2hhcnQsXG4gICAgICAgICAgc21hcnRMYWJlbDogc21hcnRMYWJlbCxcbiAgICAgICAgICBjaGFydENvbnRhaW5lcjogY29udGFpbmVyXG4gICAgICAgIH0sXG4gICAgICAgIGFwcGx5ID0gZnVuY3Rpb24gKHNldCkge1xuICAgICAgICAgIHZhciBtb2RlbCA9IGNvbmZpZy5jb21wb3NpdGlvbi5yZWFjdGl2ZU1vZGVsLFxuICAgICAgICAgICAgdGltZVBlcmlvZFZhbCA9IHRpbWVQZXJpb2RTZWxlY3RNZW51LnZhbHVlKCksXG4gICAgICAgICAgICB0aW1lUGVyaW9kTXVsdGlwbGllclZhbCA9IHRpbWVNdWxTZWxlY3RNZW51LnZhbHVlKCksXG4gICAgICAgICAgICBhZ2dNZXRob2RTZWxlY3RNZW51VmFsID0gYWdnTWV0aG9kU2VsZWN0TWVudS52YWx1ZSgpLFxuICAgICAgICAgICAga2V5cyxcbiAgICAgICAgICAgIHRpbWVJbnRlcnZhbCxcbiAgICAgICAgICAgIGNhbnZhcyA9IGNvbmZpZy5jb21wb3NpdGlvbi5pbXBsO1xuXG4gICAgICAgICAgZm9yIChrZXlzIG9mIGNvbmZpZy5hdmxUaW1lUGVyaW9kcykge1xuICAgICAgICAgICAgaWYgKGtleXMubmFtZSA9PT0gdGltZVBlcmlvZFZhbCkge1xuICAgICAgICAgICAgICB0aW1lSW50ZXJ2YWwgPSBrZXlzLmludGVydmFsO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2V0ICYmIGlzRmluaXRlKG1vZGVsLnByb3AoJ2Jpbi1zaXplJykpKSB7XG4gICAgICAgICAgICBtb2RlbFxuICAgICAgICAgICAgICAubG9jaygpXG4gICAgICAgICAgICAgIC5wcm9wKCdiaW4tc2l6ZS1leHQnLCAodGltZUludGVydmFsICogTnVtYmVyKHRpbWVQZXJpb2RNdWx0aXBsaWVyVmFsKSkpXG4gICAgICAgICAgICAgIC5wcm9wKCdhZ2dyZWdhdGlvbi1mbi1leHQnLCBjb25maWcuYXZsQWdnTWV0aG9kc1thZ2dNZXRob2RTZWxlY3RNZW51VmFsXSlcbiAgICAgICAgICAgICAgLnVubG9jaygpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYW52YXMucmVzZXRBZ2dyZWdhdGlvbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBhcHBseUJ1dHRvbi51cGRhdGVWaXN1YWwoJ2Rpc2FibGUnKTtcbiAgICAgICAgICAvLyBhcHBseUJ1dHRvbi51cGRhdGVWaXN1YWwoJ2VuYWJsZScpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRpbWVQZXJpb2RPbkNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgdGltZVBlcmlvZFZhbCA9IHRpbWVQZXJpb2RTZWxlY3RNZW51LnZhbHVlKCksXG4gICAgICAgICAgICB0aW1lUGVyaW9kTXVsdGlwbGllclZhbCA9IHRpbWVNdWxTZWxlY3RNZW51LnZhbHVlKCksXG4gICAgICAgICAgICBwcmV2VGltZVBlcm9pZE11bFZhbCA9IHRpbWVQZXJpb2RNdWx0aXBsaWVyVmFsLFxuICAgICAgICAgICAgdmFsaWRUaW1lUGVyaW9kID0gY29uZmlnLnZhbGlkVGltZVBlcmlvZCxcbiAgICAgICAgICAgIHZhbGlkVGltZVBlcmlvZE11bHRpcGxpZXIgPSBjb25maWcudmFsaWRUaW1lUGVyaW9kTXVsdGlwbGllcixcbiAgICAgICAgICAgIGluZGV4T2ZUaW1lVW5pdCxcbiAgICAgICAgICAgIGluZGV4T2ZUaW1lTXVsO1xuXG4gICAgICAgICAgaW5kZXhPZlRpbWVVbml0ID0gdmFsaWRUaW1lUGVyaW9kLmluZGV4T2YodGltZVBlcmlvZFZhbCk7XG4gICAgICAgICAgaW5kZXhPZlRpbWVNdWwgPSB2YWxpZFRpbWVQZXJpb2RNdWx0aXBsaWVyW2luZGV4T2ZUaW1lVW5pdF0uaW5kZXhPZihOdW1iZXIodGltZVBlcmlvZE11bHRpcGxpZXJWYWwpKTtcblxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGluZGV4T2ZUaW1lVW5pdCwgaW5kZXhPZlRpbWVNdWwpO1xuICAgICAgICAgIHRpbWVNdWxTZWxlY3RNZW51T3B0ID0gJyc7XG4gICAgICAgICAgZm9yIChtdWx0aXBsaWVyVmFsIG9mIHZhbGlkVGltZVBlcmlvZE11bHRpcGxpZXJbaW5kZXhPZlRpbWVVbml0XSkge1xuICAgICAgICAgICAgdGltZU11bFNlbGVjdE1lbnVPcHQgKz0gJzxvcHRpb24gdmFsdWU9XCInICsgbXVsdGlwbGllclZhbCArICdcIj4nICsgbXVsdGlwbGllclZhbCArICc8L29wdGlvbj4nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRpbWVNdWxTZWxlY3RNZW51LnVwZGF0ZUxpc3QodGltZU11bFNlbGVjdE1lbnVPcHQpO1xuXG4gICAgICAgICAgaWYgKGluZGV4T2ZUaW1lTXVsIDwgMCkge1xuICAgICAgICAgICAgdGltZU11bFNlbGVjdE1lbnUudmFsdWUodmFsaWRUaW1lUGVyaW9kTXVsdGlwbGllcltpbmRleE9mVGltZVVuaXRdWzBdLnRvU3RyaW5nKCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aW1lTXVsU2VsZWN0TWVudS52YWx1ZShwcmV2VGltZVBlcm9pZE11bFZhbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICBncm91cCA9IG5ldyBDb21wb25lbnRHcm91cChkZXBlbmRlbmNpZXMpO1xuICAgICAgdG9vbGJhciA9IG5ldyBIb3Jpem9udGFsVG9vbGJhcihkZXBlbmRlbmNpZXMpO1xuXG4gICAgICBncm91cC5zZXRDb25maWcoe1xuICAgICAgICBmaWxsOiAnI2ZmZicsXG4gICAgICAgIGJvcmRlclRoaWNrbmVzczogMFxuICAgICAgfSk7XG5cbiAgICAgIHRvb2xiYXIuc2V0Q29uZmlnKHtcbiAgICAgICAgZmlsbDogJyNmZmYnLFxuICAgICAgICBib3JkZXJUaGlja25lc3M6IDBcbiAgICAgIH0pO1xuXG4gICAgICBsYWJlbCA9IG5ldyB0b29sYm94LkxhYmVsKCdBZ2dyZWdhdGUgRGF0YTonLCBkZXBlbmRlbmNpZXMsIHtcbiAgICAgICAgdGV4dDoge1xuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAnZm9udC1zaXplJzogJzE0JyxcbiAgICAgICAgICAgICdmaWxsJzogJyM2OTY5NjknXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdG9vbGJveENvbXBDb25maWcudGltZVBlcmlvZFNlbGVjdE1lbnUgPSB0aW1lUGVyaW9kU2VsZWN0TWVudSA9IG5ldyB0b29sYm94LlNlbGVjdFN5bWJvbCh7XG4gICAgICAgIHdpZHRoOiA5MCxcbiAgICAgICAgaGVpZ2h0OiAyMFxuICAgICAgfSwgZGVwZW5kZW5jaWVzLCB7XG4gICAgICAgIGlubmVySFRNTDogJzxvcHRpb24gdmFsdWU9XCJ0aW1lXCI+VGltZSBQZXJpb2Q8L29wdGlvbj4nXG4gICAgICB9LCB7XG4gICAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAgICBzdHJva2U6ICdyZ2JhKDEwMiwxMDIsMTAyLDAuNSknLFxuICAgICAgICBzeW1ib2xTdHJva2VXaWR0aDogMCxcbiAgICAgICAgYnRuVGV4dFN0eWxlOiB7XG4gICAgICAgICAgZm9udFNpemU6IDExXG4gICAgICAgIH0sXG4gICAgICAgIGhvdmVyRmlsbDogJyMxZTFmMWYnXG4gICAgICB9KTtcblxuICAgICAgdG9vbGJveENvbXBDb25maWcudGltZU11bFNlbGVjdE1lbnUgPSB0aW1lTXVsU2VsZWN0TWVudSA9IG5ldyB0b29sYm94LlNlbGVjdFN5bWJvbCh7XG4gICAgICAgIHdpZHRoOiA1MCxcbiAgICAgICAgaGVpZ2h0OiAyMFxuICAgICAgfSwgZGVwZW5kZW5jaWVzLCB7XG4gICAgICAgIGlubmVySFRNTDogJzxvcHRpb24gdmFsdWU9XCJudW1iZXJcIj5NdWx0aXBsaWVyPC9vcHRpb24+J1xuICAgICAgfSwge1xuICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgc3Ryb2tlOiAncmdiYSgxMDIsMTAyLDEwMiwwLjUpJyxcbiAgICAgICAgc3ltYm9sU3Ryb2tlV2lkdGg6IDAsXG4gICAgICAgIGJ0blRleHRTdHlsZToge1xuICAgICAgICAgIGZvbnRTaXplOiAxMVxuICAgICAgICB9LFxuICAgICAgICBob3ZlckZpbGw6ICcjMWUxZjFmJ1xuICAgICAgfSk7XG5cbiAgICAgIHRvb2xib3hDb21wQ29uZmlnLmFnZ01ldGhvZFNlbGVjdE1lbnUgPSBhZ2dNZXRob2RTZWxlY3RNZW51ID0gbmV3IHRvb2xib3guU2VsZWN0U3ltYm9sKHtcbiAgICAgICAgd2lkdGg6IDkwLFxuICAgICAgICBoZWlnaHQ6IDIwXG4gICAgICB9LCBkZXBlbmRlbmNpZXMsIHtcbiAgICAgICAgaW5uZXJIVE1MOiAnPG9wdGlvbiB2YWx1ZT1cIkZvcm11bGFcIj5NZXRob2Q8L29wdGlvbj4nXG4gICAgICB9LCB7XG4gICAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAgICBzdHJva2U6ICdyZ2JhKDEwMiwxMDIsMTAyLDAuNSknLFxuICAgICAgICBzeW1ib2xTdHJva2VXaWR0aDogMCxcbiAgICAgICAgYnRuVGV4dFN0eWxlOiB7XG4gICAgICAgICAgZm9udFNpemU6IDExXG4gICAgICAgIH0sXG4gICAgICAgIGhvdmVyRmlsbDogJyMxZTFmMWYnXG4gICAgICB9KTtcblxuICAgICAgdG9vbGJveENvbXBDb25maWcuYXBwbHlCdXR0b24gPSBhcHBseUJ1dHRvbiA9IG5ldyB0b29sYm94LlN5bWJvbCgnQVBQTFknLCB0cnVlLCBkZXBlbmRlbmNpZXMsIHtcbiAgICAgICAgZmlsbDogJyM1NTUnLFxuICAgICAgICBsYWJlbEZpbGw6ICcjZmZmJyxcbiAgICAgICAgaG92ZXJGaWxsOiAnIzU1NScsXG4gICAgICAgIHdpZHRoOiAzMCxcbiAgICAgICAgaGVpZ2h0OiAyMCxcbiAgICAgICAgYnRuVGV4dFN0eWxlOiB7XG4gICAgICAgICAgZm9udFNpemU6IDExXG4gICAgICAgIH1cbiAgICAgIH0pLmF0dGFjaEV2ZW50SGFuZGxlcnMoe1xuICAgICAgICBjbGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGFwcGx5KDEpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRvb2xib3hDb21wQ29uZmlnLnJlc2V0QnV0dG9uID0gcmVzZXRCdXR0b24gPSBuZXcgdG9vbGJveC5TeW1ib2woJ1JFU0VUJywgdHJ1ZSwgZGVwZW5kZW5jaWVzLCB7XG4gICAgICAgIGZpbGw6ICcjODk4YjhiJyxcbiAgICAgICAgbGFiZWxGaWxsOiAnI2ZmZicsXG4gICAgICAgIGhvdmVyRmlsbDogJyM4OThiOGInLFxuICAgICAgICB3aWR0aDogMzAsXG4gICAgICAgIGhlaWdodDogMjAsXG4gICAgICAgIGJ0blRleHRTdHlsZToge1xuICAgICAgICAgIGZvbnRTaXplOiAxMVxuICAgICAgICB9XG4gICAgICB9KS5hdHRhY2hFdmVudEhhbmRsZXJzKHtcbiAgICAgICAgY2xpY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBhcHBseSgwKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGdyb3VwLmFkZFN5bWJvbChsYWJlbCk7XG4gICAgICBncm91cC5hZGRTeW1ib2wodGltZU11bFNlbGVjdE1lbnUpO1xuICAgICAgZ3JvdXAuYWRkU3ltYm9sKHRpbWVQZXJpb2RTZWxlY3RNZW51KTtcbiAgICAgIGdyb3VwLmFkZFN5bWJvbChhZ2dNZXRob2RTZWxlY3RNZW51KTtcbiAgICAgIGdyb3VwLmFkZFN5bWJvbChhcHBseUJ1dHRvbik7XG4gICAgICBncm91cC5hZGRTeW1ib2wocmVzZXRCdXR0b24pO1xuXG4gICAgICBTeW1ib2xTdG9yZS5yZWdpc3RlcigndGV4dEJveEljb24nLCBmdW5jdGlvbiAoeCwgeSwgcmFkLCB3LCBoLCBwYWRYLCBwYWRZKSB7XG4gICAgICAgIHZhciB4MSA9IHggLSB3IC8gMiArIHBhZFggLyAyLFxuICAgICAgICAgIHgyID0geCArIHcgLyAyIC0gcGFkWCAvIDIsXG4gICAgICAgICAgeTEgPSB5IC0gaCAvIDIgKyBwYWRZIC8gMixcbiAgICAgICAgICB5MiA9IHkgKyBoIC8gMiAtIHBhZFkgLyAyO1xuXG4gICAgICAgIHJldHVybiBbJ00nLCB4MSwgeTEsICdMJywgeDIsIHkxLCAnTCcsIHgyLCB5MiwgJ0wnLCB4MSwgeTIsICdaJ107XG4gICAgICB9KTtcblxuICAgICAgdGltZU11bFNlbGVjdE1lbnUuYXR0YWNoRXZlbnRIYW5kbGVycyh7XG4gICAgICAgIGNsaWNrOiB7XG4gICAgICAgICAgZm46IHRpbWVNdWxTZWxlY3RNZW51LmVkaXRcbiAgICAgICAgfSxcbiAgICAgICAgdGV4dE9uQmx1cjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRpbWVNdWxTZWxlY3RNZW51LmJsdXIoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aW1lUGVyaW9kU2VsZWN0TWVudS5hdHRhY2hFdmVudEhhbmRsZXJzKHtcbiAgICAgICAgY2xpY2s6IHtcbiAgICAgICAgICBmbjogdGltZVBlcmlvZFNlbGVjdE1lbnUuZWRpdFxuICAgICAgICB9LFxuICAgICAgICB0ZXh0T25CbHVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGltZVBlcmlvZFNlbGVjdE1lbnUuYmx1cigpO1xuICAgICAgICB9LFxuICAgICAgICB0ZXh0T25DaGFuZ2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aW1lUGVyaW9kU2VsZWN0TWVudS5ibHVyKCk7XG4gICAgICAgICAgdGltZVBlcmlvZE9uQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgYWdnTWV0aG9kU2VsZWN0TWVudS5hdHRhY2hFdmVudEhhbmRsZXJzKHtcbiAgICAgICAgY2xpY2s6IHtcbiAgICAgICAgICBmbjogYWdnTWV0aG9kU2VsZWN0TWVudS5lZGl0XG4gICAgICAgIH0sXG4gICAgICAgIHRleHRPbkJsdXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBhZ2dNZXRob2RTZWxlY3RNZW51LmJsdXIoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHRvb2xiYXIuYWRkQ29tcG9uZW50KGdyb3VwKTtcblxuICAgICAgcmV0dXJuIHRvb2xiYXI7XG4gICAgfVxuXG4gICAgZ2V0TG9naWNhbFNwYWNlIChhdmFpbGFibGVXaWR0aCwgYXZhaWxhYmxlSGVpZ2h0KSB7XG4gICAgICB2YXIgbG9naWNhbFNwYWNlLFxuICAgICAgICB3aWR0aCA9IDAsXG4gICAgICAgIGhlaWdodCA9IDAsXG4gICAgICAgIGksXG4gICAgICAgIGxuO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsbiA9IHRoaXMudG9vbGJhcnMubGVuZ3RoOyBpIDwgbG47IGkrKykge1xuICAgICAgICBsb2dpY2FsU3BhY2UgPSB0aGlzLnRvb2xiYXJzW2ldLmdldExvZ2ljYWxTcGFjZSgpO1xuICAgICAgICB3aWR0aCA9IE1hdGgubWF4KGxvZ2ljYWxTcGFjZS53aWR0aCwgd2lkdGgpO1xuICAgICAgICBoZWlnaHQgKz0gbG9naWNhbFNwYWNlLmhlaWdodDtcbiAgICAgICAgdGhpcy50b29sYmFyc1tpXS53aWR0aCA9IGxvZ2ljYWxTcGFjZS53aWR0aDtcbiAgICAgICAgdGhpcy50b29sYmFyc1tpXS5oZWlnaHQgPSBsb2dpY2FsU3BhY2UuaGVpZ2h0O1xuICAgICAgfVxuICAgICAgaGVpZ2h0ICs9IHRoaXMucGFkZGluZztcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiB3aWR0aCA+IGF2YWlsYWJsZVdpZHRoID8gMCA6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCA+IGF2YWlsYWJsZUhlaWdodCA/IDAgOiBoZWlnaHRcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcGxhY2VJbkNhbnZhcyAoY29udGFpbmVySW5zdGFuY2UpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgdHNPYmplY3QgPSBzZWxmLnRzT2JqZWN0O1xuXG4gICAgICBzZWxmLnBhZGRpbmcgPSA1O1xuICAgICAgdHNPYmplY3Quc3BhY2VNYW5hZ2VySW5zdGFuY2UuYWRkKFt7XG4gICAgICAgIG5hbWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gJ0RhdGFBZ2dyZWdhdG9yJztcbiAgICAgICAgfSxcbiAgICAgICAgcmVmOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgcmV0dXJuIG9ialsnMCddO1xuICAgICAgICB9LFxuICAgICAgICBzZWxmOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH0sXG4gICAgICAgIHByaW9yaXR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH0sXG4gICAgICAgIGxheW91dDogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgIHJldHVybiBvYmouaW5saW5lO1xuICAgICAgICB9LFxuICAgICAgICBvcmllbnRhdGlvbjogW3tcbiAgICAgICAgICB0eXBlOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqLmhvcml6b250YWw7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBwb3NpdGlvbjogW3tcbiAgICAgICAgICAgIHR5cGU6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG9iai50b3A7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWxpZ25tZW50OiBbe1xuICAgICAgICAgICAgICB0eXBlOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iai5sZWZ0O1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkaW1lbnNpb25zOiBbZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLmdldFBhcmVudENvbXBvbmVudEdyb3VwKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZ2V0TG9naWNhbFNwYWNlKHBhcmVudC5nZXRXaWR0aCgpLCBwYXJlbnQuZ2V0SGVpZ2h0KCkpO1xuICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfV1cbiAgICAgICAgICB9XVxuICAgICAgICB9XVxuICAgICAgfV0pO1xuICAgIH1cblxuICAgIHNldERyYXdpbmdDb25maWd1cmF0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBncm91cCkge1xuICAgICAgdmFyIG1lcyA9IHRoaXMubWVhc3VyZW1lbnQ7XG4gICAgICBtZXMueCA9IHg7XG4gICAgICBtZXMueSA9IHk7XG4gICAgICBtZXMud2lkdGggPSB3aWR0aDtcbiAgICAgIG1lcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgIHRoaXMucGFyZW50R3JvdXAgPSBncm91cDtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZHJhdyAoeCwgeSwgd2lkdGgsIGhlaWdodCwgZ3JvdXApIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgY29uZmlnID0gc2VsZi5jb25maWcsXG4gICAgICAgIHRvb2xib3hDb21wQ29uZmlnID0gY29uZmlnLnRvb2xib3hDb21wb25lbnQuY29uZmlnLFxuICAgICAgICB0aW1lUGVyaW9kU2VsZWN0TWVudSA9IHRvb2xib3hDb21wQ29uZmlnLnRpbWVQZXJpb2RTZWxlY3RNZW51LFxuICAgICAgICB0aW1lTXVsU2VsZWN0TWVudSA9IHRvb2xib3hDb21wQ29uZmlnLnRpbWVNdWxTZWxlY3RNZW51LFxuICAgICAgICBhZ2dNZXRob2RTZWxlY3RNZW51ID0gdG9vbGJveENvbXBDb25maWcuYWdnTWV0aG9kU2VsZWN0TWVudSxcbiAgICAgICAgY3VycmVudEFnZ3JlZ2F0aW9uT2JqLFxuICAgICAgICBtZWFzdXJlbWVudCA9IHNlbGYubWVhc3VyZW1lbnQsXG4gICAgICAgIHRvb2xiYXJzID0gc2VsZi50b29sYmFycyxcbiAgICAgICAgbG4sXG4gICAgICAgIGksXG4gICAgICAgIHRvb2xiYXIsXG4gICAgICAgIG1vZGVsID0gY29uZmlnLmNvbXBvc2l0aW9uLnJlYWN0aXZlTW9kZWwsXG5cbiAgICAgICAgdGltZVBlcmlvZFZhbCxcbiAgICAgICAgdGltZVBlcmlvZFNlbGVjdE1lbnVPcHQsXG4gICAgICAgIHZhbGlkVGltZVBlcmlvZCxcbiAgICAgICAgaW5kZXhPZlRpbWVVbml0LFxuXG4gICAgICAgIG11bHRpcGxpZXJWYWwsXG4gICAgICAgIHRpbWVNdWxTZWxlY3RNZW51T3B0LFxuICAgICAgICB2YWxpZFRpbWVQZXJpb2RNdWx0aXBsaWVyLFxuXG4gICAgICAgIGFnZ1ZhbCxcbiAgICAgICAgYWdnTWV0aG9kU2VsZWN0TWVudU9wdCxcbiAgICAgICAgYXZsQWdnTWV0aG9kcyxcbiAgICAgICAgcmFuZ2VPbkNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgYXR0clN0ciA9ICcnO1xuXG4gICAgICAgICAgc2VsZi5nZXRWYWxpZEFnZ3JlZ2F0aW9uKCk7XG4gICAgICAgICAgY3VycmVudEFnZ3JlZ2F0aW9uT2JqID0gc2VsZi5nZXRDdXJyZW50QWdncmVhdGlvbigpO1xuXG4gICAgICAgICAgdGltZVBlcmlvZFNlbGVjdE1lbnVPcHQgPSAnJztcbiAgICAgICAgICB0aW1lTXVsU2VsZWN0TWVudU9wdCA9ICcnO1xuICAgICAgICAgIGFnZ01ldGhvZFNlbGVjdE1lbnVPcHQgPSAnJztcblxuICAgICAgICAgIHZhbGlkVGltZVBlcmlvZCA9IGNvbmZpZy52YWxpZFRpbWVQZXJpb2Q7XG4gICAgICAgICAgdmFsaWRUaW1lUGVyaW9kTXVsdGlwbGllciA9IGNvbmZpZy52YWxpZFRpbWVQZXJpb2RNdWx0aXBsaWVyO1xuICAgICAgICAgIGF2bEFnZ01ldGhvZHMgPSBjb25maWcuYXZsQWdnTWV0aG9kcztcblxuICAgICAgICAgIGlmICghY29uZmlnLmNhbkFnZ3JlZ2F0ZSkge1xuICAgICAgICAgICAgYXR0clN0ciA9ICdkaXNhYmxlZCBoaWRkZW4nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAodGltZVBlcmlvZFZhbCBvZiB2YWxpZFRpbWVQZXJpb2QpIHtcbiAgICAgICAgICAgIHRpbWVQZXJpb2RTZWxlY3RNZW51T3B0ICs9ICc8b3B0aW9uICcgKyBhdHRyU3RyICsgJyB2YWx1ZT1cIicgKyB0aW1lUGVyaW9kVmFsICsgJ1wiPicgK1xuICAgICAgICAgICAgdGltZVBlcmlvZFZhbC50b1VwcGVyQ2FzZSgpICsgJzwvb3B0aW9uPic7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGltZVBlcmlvZFNlbGVjdE1lbnUudXBkYXRlTGlzdCh0aW1lUGVyaW9kU2VsZWN0TWVudU9wdCk7XG4gICAgICAgICAgdGltZVBlcmlvZFNlbGVjdE1lbnUudmFsdWUoY3VycmVudEFnZ3JlZ2F0aW9uT2JqLnRpbWVQZXJpb2QpO1xuXG4gICAgICAgICAgaW5kZXhPZlRpbWVVbml0ID0gdmFsaWRUaW1lUGVyaW9kLmluZGV4T2YoY3VycmVudEFnZ3JlZ2F0aW9uT2JqLnRpbWVQZXJpb2QpO1xuXG4gICAgICAgICAgaWYgKGluZGV4T2ZUaW1lVW5pdCA+PSAwKSB7XG4gICAgICAgICAgICBmb3IgKG11bHRpcGxpZXJWYWwgb2YgdmFsaWRUaW1lUGVyaW9kTXVsdGlwbGllcltpbmRleE9mVGltZVVuaXRdKSB7XG4gICAgICAgICAgICAgIHRpbWVNdWxTZWxlY3RNZW51T3B0ICs9ICc8b3B0aW9uICcgKyBhdHRyU3RyICsgJyB2YWx1ZT1cIicgKyBtdWx0aXBsaWVyVmFsICsgJ1wiPicgK1xuICAgICAgICAgICAgICBtdWx0aXBsaWVyVmFsLnRvU3RyaW5nKCkudG9VcHBlckNhc2UoKSArICc8L29wdGlvbj4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRpbWVNdWxTZWxlY3RNZW51LnVwZGF0ZUxpc3QodGltZU11bFNlbGVjdE1lbnVPcHQpO1xuICAgICAgICAgIHRpbWVNdWxTZWxlY3RNZW51LnZhbHVlKGN1cnJlbnRBZ2dyZWdhdGlvbk9iai50aW1lUGVyaW9kTXVsdGlwbGllci50b1N0cmluZygpKTtcblxuICAgICAgICAgIGZvciAoYWdnVmFsIGluIGF2bEFnZ01ldGhvZHMpIHtcbiAgICAgICAgICAgIGFnZ01ldGhvZFNlbGVjdE1lbnVPcHQgKz0gJzxvcHRpb24gJyArIGF0dHJTdHIgKyAnIHZhbHVlPVwiJyArXG4gICAgICAgICAgICAgIGF2bEFnZ01ldGhvZHNbYWdnVmFsXS5uaWNrTmFtZSArICdcIj4nICsgYXZsQWdnTWV0aG9kc1thZ2dWYWxdLmZvcm1hbE5hbWUudG9VcHBlckNhc2UoKSArICc8L29wdGlvbj4nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFnZ01ldGhvZFNlbGVjdE1lbnUudXBkYXRlTGlzdChhZ2dNZXRob2RTZWxlY3RNZW51T3B0KTtcbiAgICAgICAgICBhZ2dNZXRob2RTZWxlY3RNZW51LnZhbHVlKGN1cnJlbnRBZ2dyZWdhdGlvbk9iai5hZ2dyZWdhdGlvbk1ldGhvZC52YWx1ZSk7XG4gICAgICAgIH07XG5cbiAgICAgIHNlbGYuZ2V0QXZhaWxhYmxlbEFnZ3JlYWdhdGlvbigpO1xuXG4gICAgICB4ID0geCA9PT0gdW5kZWZpbmVkID8gbWVhc3VyZW1lbnQueCA6IHg7XG4gICAgICB5ID0geSA9PT0gdW5kZWZpbmVkID8gbWVhc3VyZW1lbnQueSA6IHk7XG4gICAgICB3aWR0aCA9IHdpZHRoID09PSB1bmRlZmluZWQgPyBtZWFzdXJlbWVudC53aWR0aCA6IHdpZHRoO1xuICAgICAgaGVpZ2h0ID0gaGVpZ2h0ID09PSB1bmRlZmluZWQgPyBtZWFzdXJlbWVudC5oZWlnaHQgOiBoZWlnaHQ7XG4gICAgICBncm91cCA9IGdyb3VwID09PSB1bmRlZmluZWQgPyBzZWxmLnBhcmVudEdyb3VwIDogZ3JvdXA7XG4gICAgICBpZiAod2lkdGggJiYgaGVpZ2h0KSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGxuID0gdG9vbGJhcnMubGVuZ3RoOyBpIDwgbG47IGkrKykge1xuICAgICAgICAgIHRvb2xiYXIgPSB0b29sYmFyc1tpXTtcbiAgICAgICAgICB0b29sYmFyLmRyYXcoeCwgeSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJhbmdlT25DaGFuZ2UoKTtcblxuICAgICAgbW9kZWwub25Qcm9wc0NoYW5nZShbJ2Jpbi1zaXplJywgJ2FnZ3JlZ2F0aW9uLWZuJ10sIHJhbmdlT25DaGFuZ2UpO1xuICAgIH1cblxuICAgIGRpc3Bvc2UgKCkge1xuICAgICAgLy8gZGlzcG9zZSBleHRlbnNpb25cbiAgICB9XG4gIH1cbiAgcmV0dXJuIEFnZ3JlZ2F0b3I7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvZmN0cy1leHQtYWdncmVnYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXX0=
