<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>fcts-ext-aggregator.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Aggregator.html">Aggregator</a><ul class='methods'><li data-type='method'><a href="Aggregator.html#resetAggregation">resetAggregation</a></li><li data-type='method'><a href="Aggregator.html#setAggregation">setAggregation</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">fcts-ext-aggregator.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';
/**
 * Class representing the Data Aggregator.
 */
class Aggregator {
  /**
   * Create a Aggregator.
   * @typedef {object} Aggregator.aggregation
   * @property {string} timePeriod - The time interval of aggregation.
   * @property {number} timePeriodMultiplier - The multiplier of time interval.
   * @property {string} aggregationMethod - The method applied to aggregate.
   */
  constructor () {
    /**
     * @private
     */
    this.appliedAggregation = {
      timePeriod: null,
      timePeriodMultiplier: 1,
      aggregationMethod: null
    };
    this.config = {};
  }

  /**
   * An object representing the timePeriod, timePeriodMultiplier, aggregationMethod.
   * @type {Aggregator.aggregation}
   */
  get aggregation () {
    return this.appliedAggregation;
  }

  set aggregation (obj) {
    this.appliedAggregation.timePeriod = obj.timePeriod;
    this.appliedAggregation.timePeriodMultiplier = obj.timePeriodMultiplier;
    this.appliedAggregation.aggregationMethod = obj.aggregationMethod;
  }

  /**
   * Sets available aggregation options in configuration of extension
   * @private
   */
  getAvailablelAggreagation () {
    var config = this.config,
      chart = this.chart,
      avlTimePeriods,
      i,
      len;

    config.avlAggMethods = chart.getAvailableAggregationMethod();
    avlTimePeriods = config.avlTimePeriods = chart.getAvailableTimePeriod();

    config.avlTimeMultiplier = [];
    len = avlTimePeriods.length;

    for (i = 0; i &lt; len; i++) {
      config.avlTimeMultiplier.push(avlTimePeriods[i].multipliers);
    }
  }

  /**
   * Calculates valid aggregation time periods and corresponding multipliers
   * @private
   */
  getValidAggregation () {
    var chartConfig = this.chart.config,
      config = this.config,
      xAxis = this.x,
      i,
      j,
      len1,
      len2,
      avlTimePeriods,
      avlTimeMultiplier,
      minNumOfPlot = chartConfig.minNumOfPlot,
      maxNumOfPlot = chartConfig.maxNumOfPlot,
      multipliersArr,
      currentTimeLength,
      timePeriod,
      time,
      expectedTime,
      multiplier,
      minTime,
      maxTime,
      currentVisibleRange;

    config.currentVisibleRange = currentVisibleRange = xAxis.getCurrentVisibleRange();
    config.currentTimeLength = currentVisibleRange.endDate - currentVisibleRange.startDate;

    avlTimePeriods = config.avlTimePeriods;
    avlTimeMultiplier = config.avlTimeMultiplier;
    currentTimeLength = config.currentTimeLength;

    config.minTime = minTime = currentTimeLength / maxNumOfPlot;
    config.maxTime = maxTime = currentTimeLength / minNumOfPlot;

    config.validTimePeriod = [];
    config.validTimePeriodMultiplier = [];

    for (i = 0, len1 = avlTimePeriods.length; i &lt; len1; i++) {
      timePeriod = Object.keys(avlTimePeriods[i])[0];
      time = avlTimePeriods[i][Object.keys(avlTimePeriods[i])[0]];
      multipliersArr = [];

      for (j = 0, len2 = avlTimeMultiplier[i].length; j &lt; len2; j++) {
        multiplier = avlTimeMultiplier[i][j];
        expectedTime = multiplier * time;

        if ((expectedTime >= minTime) &amp;&amp; (expectedTime &lt;= maxTime)) {
          multipliersArr.push(avlTimeMultiplier[i][j]);
        }
      }
      if (multipliersArr.length > 0) {
        config.validTimePeriodMultiplier.push(multipliersArr);
        config.validTimePeriod.push(timePeriod);
      }
    }
    console.log('Time Period: ', config.validTimePeriod);
    console.log('Number Of Multipliers: ', config.validTimePeriodMultiplier);
    console.log('Methods: ', config.avlAggMethods);
  }

  /**
   * Set Aggregation on time series
   * @param  {object} obj
   * @property {string} timePeriod - The time interval of aggregation.
   * @property {number} timePeriodMultiplier - The multiplier of time interval.
   * @property {string} aggregationMethod - The method applied to aggregate.
   */
  setAggregation (obj) {
    var avlAggMethods,
      validTimePeriod,
      timePeriodIndex,
      validTimePeriodMultiplier,
      config = this.config;

    avlAggMethods = config.avlAggMethods;
    validTimePeriod = config.validTimePeriod;
    validTimePeriodMultiplier = config.validTimePeriodMultiplier;

    if (avlAggMethods.includes(obj.aggregationMethod) &amp;&amp; validTimePeriod.includes(obj.timePeriod)) {
      timePeriodIndex = validTimePeriod.indexOf(obj.timePeriod);
      if (validTimePeriodMultiplier[timePeriodIndex].includes(Number(obj.timePeriodMultiplier))) {
        this.aggregation = obj;
        console.log(this.aggregation);
        return true;
      } else {
        console.log(this.aggregation);
        return false;
      }
    } else {
      console.log(this.aggregation);
      return false;
    }
  }

  /**
   * Reset Applied Aggregation
   */
  resetAggregation () {

  }

  init (require) {
    var self = this;

    require('X-Axis', 'chart', function (x, chart) {
      self.x = x;
      self.chart = chart;
    });

    this.getAvailablelAggreagation();
    this.getValidAggregation();
  }

  placeInCanvas () {
    // space management
  }

  draw () {
    // var multiplierFld,
    //   timePeriodFld,
    //   AggMethodFld,
    //   // chart = this.chart,
    //   config = this.config,
    //   // currentAggregation,
    //   label,
    //   mainCont = $('#mainCont'),
    //   validTimePeriod = config.validTimePeriod,
    //   validTimePeriodMultiplier = config.validTimePeriodMultiplier,
    //   indexOfTimeUnit,
    //   avlAggMethods = config.avlAggMethods,
    //   timePeriodOnChange = function () {
    //     var timePeriodVal = $('#time_period').val(),
    //       timePeriodMultiplierVal = $('#mul').val(),
    //       indexOfTimeUnit,
    //       indexOfTimeMul;

    //     indexOfTimeUnit = validTimePeriod.indexOf(timePeriodVal);
    //     indexOfTimeMul = validTimePeriodMultiplier[indexOfTimeUnit].indexOf(Number(timePeriodMultiplierVal));

    //     $('#mul').empty();
    //     console.log(indexOfTimeUnit, indexOfTimeMul);

    //     for (var mulVal of validTimePeriodMultiplier[indexOfTimeUnit]) {
    //       $('&lt;option />', {text: mulVal}).appendTo(multiplierFld);
    //     }

    //     if (indexOfTimeMul &lt; 0) {
    //       $('#mul').val(validTimePeriodMultiplier[indexOfTimeUnit][0]);
    //     } else {
    //       $('#mul').val(timePeriodMultiplierVal);
    //     }
    //   };

    // // currentAggregation = chart.getAggregation();

    // if (mainCont.length === 0) {
    //   return;
    // }

    // mainCont.empty();

    // label = $('&lt;label>').text('Aggregate Data: ');
    // label.appendTo(mainCont);

    // multiplierFld = $('&lt;select id="mul"/>');
    // timePeriodFld = $('&lt;select id="time_period"/>');
    // AggMethodFld = $('&lt;select id="agg_method"/>');

    // for (var unitVal of validTimePeriod) {
    //   $('&lt;option />', {text: unitVal}).appendTo(timePeriodFld);
    // }

    // indexOfTimeUnit = validTimePeriod.indexOf(validTimePeriod[0]);

    // if (indexOfTimeUnit >= 0) {
    //   for (var mulVal of validTimePeriodMultiplier[indexOfTimeUnit]) {
    //     $('&lt;option />', {text: mulVal}).appendTo(multiplierFld);
    //   }
    // }

    // for (var aggVal of avlAggMethods) {
    //   $('&lt;option />', {text: aggVal}).appendTo(AggMethodFld);
    // }

    // multiplierFld.appendTo(mainCont);
    // // $('#mul').val(currentAggregation.timePeriodMultiplier);
    // timePeriodFld.appendTo(mainCont);
    // // $('#time_period').val(currentAggregation.timePeriod);
    // AggMethodFld.appendTo(mainCont);
    // // $('#agg_method').val(currentAggregation.aggregationMethod);

    // $('&lt;button/>').text('Apply').appendTo(mainCont);
    // $('&lt;button/>').text('Reset').appendTo(mainCont);

    // $('#time_period').change(timePeriodOnChange);
  }

  rangeChangeCallback () {
    this.getValidAggregation();
    this.draw();
  }

  dispose () {
    // dispose extension
  }
}

module.exports = Aggregator;
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.2</a> on Mon Nov 07 2016 13:42:32 GMT+0530 (IST) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
