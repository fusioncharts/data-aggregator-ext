{"version":3,"sources":["webpack:///webpack/bootstrap 687551bef3addcc56489","webpack:///./src/index.js","webpack:///./src/data-aggregator-ext.js"],"names":[],"mappings":"YACA,cAMA,MACA,eAGA,mBACA,CACA,cACA,EAIA,kDAGA,KAGA,YACA,OAIA,IAzBA,iBA4BA,MAGA,MAGA,0BCtCA,CACA,uBAEA,GAAC,cACD,uBACA,oBACA,yBACA,OACA,yBAEA,6CACA,KAEA,iBAEA,KAAC,qDACD,SAEA,2EACA,uDAA4E,GAC5E,IACA,GAAC,eCrBD,CAEA,kCAKA,kBACA,0CACA,EACA,eACA,2CACA,MACA,qBAEA,aACA,OACA,GACA,mCAGA,YACA,MAAuC,aAEvC,MAIA,EAEA,kBACA,2DACA,oBAEA,IACA,+BAGA,8CAGA,mBAGA,KACA,KAKA,mBAOA,oCAGA,QAKA,WACA,EAEA,SACA,GAGA,CACA,QAMA,WAOA,cAIA,yBACA,SACA,uBAEA,WACA,SAMA,kBACA,aACA,kBAEA,mBACA,sCACA,0DACA,iEACA,iBAMA,4BACA,IAIA,GAEA,SALA,WACA,6BACA,gCAIA,yBAEA,SAAiB,IAAS,EAC1B,kCAEA,gBAMA,sBACA,IAKA,GACA,EACA,EACA,EACA,EACA,EAGA,EACA,EACA,EACA,EACA,EACA,EAIA,IArBA,SACA,WACA,aACA,4CAOA,mDACA,iCAOA,6BACA,gEAGA,oCAEA,kCACA,mBACA,sBAEA,sBAEA,IACA,qBACA,+CAEA,mCAA+C,UAAU,MACzD,YACA,YACA,SAEA,iBAAuD,UAAU,EACjE,WACA,OAEA,UAEA,KACA,uBAGA,IACA,8CACA,0BAEA,GACA,CAMA,uBACA,IAMA,GACA,EAEA,IARA,SACA,WACA,YACA,gBACA,0CAMA,WACA,uCACA,YAGA,mBACA,iBACA,+BACA,uBACA,YACA,mBAGA,YAEA,QACA,IAGA,GAEA,EACA,EACA,IANA,SACA,WAEA,sBAIA,aACA,CACA,WACA,sBACA,QACA,uBACA,gBACA,aACA,UACA,cACA,gBACA,OACA,aACA,IACA,cACA,SACA,oBAAuB,IAAQ,IAC/B,MACA,qBAEA,EAEA,YAEA,OACA,uBAEA,0BACA,gBACA,0DACA,6BAEA,sDACA,aAEA,YAEA,cAEA,iCAEA,uFACA,GACA,YACA,0BACA,GACA,eAAW,EAEX,KAEA,qBACA,EACA,CAMA,gBACA,kBA8YA,IACA,iBACA,QACA,0CACA,sBAEA,eAGA,kCAEA,GAEA,kBACA,eACA,kBAEA,yBACA,gBACA,gBAGA,yBACA,0CAEA,qDACA,oBACA,oBACA,2CAGA,qBACA,8BACA,WACA,WACA,QACA,+DACA,OACA,UACA,6DACA,iBACA,oBACA,2DAIA,QAEA,aACA,kCAAoD,UAAS,SAC7D,WACA,IACA,qBACA,0BACA,GACA,OACA,GAEA,cACA,cACA,gBAEA,cACA,gCACA,MAEA,IA9cA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EAIA,EAeA,EACA,EAEA,IA/BA,SAUA,WACA,aAGA,qBACA,YACA,WACA,sBAEA,mBACA,aACA,yBACA,OACA,cACA,UAEA,aAMA,OACA,QACA,aACA,iBAOA,SACA,IAMA,IACA,GACA,GACA,GACA,OATA,YACA,YAEA,qBACA,6BAOA,mBACA,sBAEA,GACA,WACA,gBAAuC,WAAS,GAChD,WACA,WACA,SACA,oBAIA,0BAEA,GACA,uBAEA,cAEA,MA7BA,EAmCA,QACA,SACA,gDACA,6CAEA,sCACA,0BACA,uCACA,sBAEA,uBAGA,cACA,mBAEA,+BACA,oCACA,IAEA,IAEA,YACA,UAEA,cACA,UAEA,cACA,UAGA,YACA,OAEA,gBACA,WACA,CAKA,+DACA,UACA,QAEA,iBACA,QAIA,kBACA,OACA,MACA,sBACA,qBAGA,sCACA,OACA,MAGA,kBACA,QACA,QACA,UACA,UACA,OAKA,OACA,OACA,WACA,QACA,GAIA,iBACA,OAEA,QACA,CAQA,+HACA,aACA,iBACA,aACA,YACA,QACA,QACA,UACA,UACA,OACA,OAEA,WACA,MACA,SAGA,oBACA,MACA,YAGA,0BACA,aACA,iBACA,aACA,YACA,QACA,QACA,UACA,UACA,OACA,OAEA,WACA,MACA,SAGA,oBACA,MACA,sBACA,CACA,IACA,GAGA,yBACA,aACA,iBACA,aACA,YACA,QACA,QACA,WACA,UACA,OACA,OAEA,WACA,MACA,SAGA,oBACA,MACA,YAGA,cACA,WACA,OACA,YACA,sBACA,0BACA,qBACA,uBACA,kBACA,qBAGA,yCACA,CAEA,gBACA,OACA,CACA,iBAMA,wEACA,CACA,iBAQA,0DACA,WACA,CAKA,6DACA,CAKA,kEACA,QAIA,kBACA,CAKA,uFACA,CAKA,kCACA,QACA,QACA,UACA,UACA,OACA,OAEA,SAEA,yBACA,MACA,qBACA,SACA,EAGA,iBACA,WACA,CAKA,6DACA,OACA,QAEA,oBACA,MACA,yBACA,SACA,iBAIA,kBACA,OACA,MACA,mBACA,kBAEA,sCACA,UACA,MAIA,mBACA,QACA,EAIA,wCACA,UACA,UACA,OACA,OAEA,SAEA,yBACA,MACA,qBACA,SACA,EAKA,QAEA,IACA,oCACA,SAGA,0CAEA,mBACA,mBAGA,0DAEA,iBACA,cAEA,qBAoEA,eACA,QACA,OAIA,SACA,yBACA,4BAEA,2BACA,mBAEA,2BACA,eACA,eACA,eACA,eAEA,kBACA,kBACA,kBACA,GACA,CAEA,qBACA,IACA,GAGA,EAEA,IAJA,IACA,0BAG4C,SAAQ,EACpD,yCACA,sBACA,QACA,gCACA,gCAEA,sBACA,QACA,OACA,SAEA,EAEA,gBACA,OACA,SACA,oBAEA,oBACA,8BACA,gBACA,OACA,iBACA,iBACA,UACA,IACA,iBACA,OACA,EACA,qBACA,OACA,EACA,oBACA,oBACA,SACA,eACA,iBACA,yBACA,aACA,YACA,iBACA,sBACA,SACA,aACA,iBACA,uBACA,QACA,wBACA,YACA,kEACA,YAKA,WAEA,mCACA,YACA,uBACA,MACA,UACA,WAEA,mBAEA,EACA,IAOA,SACA,IAWA,GACA,EAEA,EACA,EACA,EAEA,EAEA,EACA,EACA,EACA,EACA,EACA,EAEA,EACA,EACA,IA5BA,SACA,4BACA,WACA,yBACA,sBACA,wBACA,gBAEA,iCACA,8BASA,kBAOA,4BAKA,SACA,IA2EA,6BACA,yBACA,gBAEA,wBA9EA,MAkDA,SACA,YACA,YACA,YACA,wBAAuC,UAAS,EAChD,WACA,cACA,KACA,SACA,KAEA,MACA,EACA,EACA,2BACA,6CACA,IACA,mBACA,sBACA,aACA,0BACA,WAEA,6CAxEA,kBACA,oCAEA,aACA,0BACA,oBACA,8BAEA,yBACA,iBACA,mBACA,YAEA,IAGA,QACA,KAGA,WACA,MACA,SACA,uBAA2C,SAAS,EACpD,WACA,cACA,KACA,SACA,KAEA,MACA,EACA,EACA,2BACA,GACA,mBACA,CAEA,CACA,IACA,EACA,iDACA,IACA,6BAEA,cACA,0BACA,WACS,CAmCT,gBACA,IAWA,GACA,EACA,EAEA,EACA,EACA,EAEA,EACA,EACA,EAEA,EAEA,EACA,EACA,EACA,EACA,EACA,EAEA,IA/BA,SACA,4BACA,WACA,yBACA,sBACA,wBACA,gBACA,4BAEA,kBAcA,kBASA,0BACA,2BACA,eACA,yBAEA,kBACA,KACA,KAEA,SACA,oBACA,8BAEA,yBAEA,+BACA,6CACA,oBAOA,uBANA,yBACA,gBAEA,sBAG+C,UAAS,EACxD,QACA,UACA,QACA,SAIA,oBACA,sCAEA,gBAEA,GACA,aACA,WAAqC,SAAS,EAC9C,QACA,UACA,QACA,mBAKA,mCACA,eACA,kCAEA,IACA,SACA,aACA,uBAIA,wBACA,qBACA,6BACA,MACA,UAEA,gBACA,IAKA,GACA,EACA,IANA,SACA,WACA,gBACA,aAKA,aAEA,6CACA,mBACA,uBACA,wBACA,6BACA,OACA,aAAyC,SAAQ,EACjD,QACA,cAGA,sDACA,0BACA,KACA,kBACA,QACA,CAEA,UAEA,CAEA,QACA","file":"data-aggregator.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 687551bef3addcc56489","'use strict';\nconst AggregatorGetter = require('./data-aggregator-ext');\n\n;(function (env, factory) {\n  if (typeof module === 'object' && module.exports) {\n    module.exports = env.document\n       ? factory(env) : function (win) {\n         if (!win.document) {\n           throw new Error('Window with document not present');\n         }\n         return factory(win, true);\n       };\n  } else {\n    env.Aggregator = factory(env, true);\n  }\n})(typeof window !== 'undefined' ? window : this, function (_window, windowExists) {\n  var FC = _window.FusionCharts;\n\n  FC.register('extension', ['private', 'data-aggregator', function () {\n    FC.registerComponent('extensions', 'data-aggregator', AggregatorGetter({FC: FC}));\n  }]);\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.js\n// module id = 0\n// module chunks = 0","'use strict';\n\nmodule.exports = function (dep) {\n  /**\n   * Capitalize the first letter of a given string and return the string\n   * @private\n   */\n  var capitalize = function (string) {\n      return string.charAt(0).toUpperCase() + string.slice(1);\n    },\n    isPlainObject = function (o) {\n      return typeof o === 'object' && o.constructor === Object;\n    },\n    mergeRecursively = function recParsing (sink, source, lib) {\n      var prop;\n      for (prop in source) {\n        if (prop in sink) {\n          if (typeof source[prop] === 'object') {\n            recParsing(sink[prop], source[prop], lib);\n          }\n        } else {\n          if (isPlainObject(source[prop])) {\n            sink[prop] = lib.extend2({}, source[prop]);\n          } else {\n            sink[prop] = source[prop];\n          }\n        }\n      }\n    };\n  // https://tc39.github.io/ecma262/#sec-array.prototype.includes\n  if (!Array.prototype.includes) {\n    Object.defineProperty(Array.prototype, 'includes', {\n      value: function (searchElement, fromIndex) {\n        // 1. Let O be ? ToObject(this value).\n        if (this == null) {\n          throw new TypeError('\"this\" is null or not defined');\n        }\n\n        var o = Object(this);\n\n        // 2. Let len be ? ToLength(? Get(O, \"length\")).\n        var len = o.length >>> 0;\n\n        // 3. If len is 0, return false.\n        if (len === 0) {\n          return false;\n        }\n\n        // 4. Let n be ? ToInteger(fromIndex).\n        //    (If fromIndex is undefined, this step produces the value 0.)\n        var n = fromIndex | 0;\n\n        // 5. If n â‰¥ 0, then\n        //  a. Let k be n.\n        // 6. Else n < 0,\n        //  a. Let k be len + n.\n        //  b. If k < 0, let k be 0.\n        var k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);\n\n        // 7. Repeat, while k < len\n        while (k < len) {\n          // a. Let elementK be the result of ? Get(O, ! ToString(k)).\n          // b. If SameValueZero(searchElement, elementK) is true, return true.\n          // c. Increase k by 1.\n          // NOTE: === provides the correct \"SameValueZero\" comparison needed here.\n          if (o[k] === searchElement) {\n            return true;\n          }\n          k++;\n        }\n\n        // 8. Return false\n        return false;\n      }\n    });\n  }\n  /**\n   * Class representing the Data Aggregator.\n   */\n  class Aggregator {\n    /**\n     * Create a Aggregator.\n     * @typedef {object} Aggregator.aggregation\n     * @property {string} binSize - The binSize applied to aggregate.\n     * @property {string} aggregationMethod - The method applied to aggregate.\n     */\n    constructor () {\n      /**\n       * @private\n       */\n      this.appliedAggregation = {\n        binSize: null,\n        aggregationMethod: null\n      };\n      this.config = {};\n    }\n\n    /**\n     * An object representing the binSize, aggregationMethod.\n     * @type {Aggregator.aggregation}\n     */\n    get aggregation () {\n      return this.appliedAggregation;\n    }\n\n    set aggregation (obj) {\n      this.appliedAggregation.timePeriod = obj.timePeriod;\n      this.appliedAggregation.timePeriodMultiplier = obj.timePeriodMultiplier;\n      this.appliedAggregation.aggregationMethod = obj.aggregationMethod;\n    }\n\n    /**\n     * Sets available aggregation options in configuration of extension\n     * @private\n     */\n    getAvailablelAggreagation () {\n      var config = this.config,\n        dataAgg = config.dataAgg,\n        avlTimePeriods = config.avlTimePeriods = dataAgg.getAggregationTimeRules(),\n        i,\n        len;\n\n      config.avlTimeMultiplier = [];\n      len = avlTimePeriods.length;\n\n      for (i = 0; i < len; i++) {\n        config.avlTimeMultiplier.push(avlTimePeriods[i].possibleFactors);\n      }\n    }\n\n    /**\n     * Calculates valid aggregation time periods and corresponding multipliers\n     * @private\n     */\n    getValidAggregation () {\n      var self = this,\n        config = self.config,\n        tsObject = self.tsObject,\n        dataAgg = config.dataAgg,\n        i,\n        j,\n        len1,\n        len2,\n        avlTimePeriods,\n        avlTimeMultiplier,\n        maxNumOfPlot = config.composition.reactiveModel.model['max-plot-point'],\n        minimumConsecutiveDifference = config.composition.dataset.category.minimumConsecutiveDifference,\n        multipliersArr,\n        currentTimeLength,\n        timePeriod,\n        time,\n        binSize,\n        multiplier,\n        globalReactiveModel = tsObject.globalReactiveModel,\n        maximumAllowedTicks = globalReactiveModel.prop('x-axis-maximum-allowed-ticks'),\n        minBinSize;\n\n      config.currentTimeLength = globalReactiveModel.model['x-axis-visible-range-end'] -\n        globalReactiveModel.model['x-axis-visible-range-start'];\n\n      avlTimePeriods = config.avlTimePeriods;\n      avlTimeMultiplier = config.avlTimeMultiplier;\n      currentTimeLength = config.currentTimeLength;\n\n      minBinSize = currentTimeLength / maxNumOfPlot;\n\n      config.validTimePeriod = [];\n      config.validTimePeriodMultiplier = [];\n      config.avlAggMethods = dataAgg.getAllAggregationMethod();\n\n      for (i = 0, len1 = avlTimePeriods.length; i < len1; i++) {\n        timePeriod = avlTimePeriods[i].name;\n        time = avlTimePeriods[i].interval;\n        multipliersArr = [];\n\n        for (j = 0, len2 = avlTimeMultiplier[i].length; j < len2; j++) {\n          multiplier = avlTimeMultiplier[i][j];\n          binSize = multiplier * time;\n\n          if ((binSize >= minBinSize) && (binSize > minimumConsecutiveDifference) &&\n            // Need to revisit\n            (currentTimeLength > maximumAllowedTicks * binSize * 0.5)) {\n            multipliersArr.push(avlTimeMultiplier[i][j]);\n          }\n        }\n        if (multipliersArr.length > 0) {\n          config.validTimePeriodMultiplier.push(multipliersArr);\n          config.validTimePeriod.push(timePeriod);\n        }\n      }\n    }\n\n    /**\n     * Returns current Aggregation applied to timeseries\n     * @private\n     */\n    getCurrentAggreation () {\n      var self = this,\n        config = self.config,\n        dataAgg = config.dataAgg,\n        composition = config.composition,\n        model = composition.reactiveModel,\n        currentAggMethod,\n        suitableInterval,\n        binSize;\n\n      binSize = model.prop('bin-size') - 1;\n\n      if (isFinite(binSize)) {\n        suitableInterval = dataAgg.timeRules.getSuitableInterval(binSize);\n        currentAggMethod = model.prop('aggregation-fn');\n      }\n\n      return {\n        timePeriod: suitableInterval && suitableInterval.name,\n        timePeriodMultiplier: suitableInterval && suitableInterval.step,\n        aggregationMethod: {\n          value: currentAggMethod && currentAggMethod.nickName,\n          text: currentAggMethod && currentAggMethod.formalName\n        }\n      };\n    }\n\n    init (require) {\n      var self = this,\n        config = self.config,\n        tsObject,\n        toolboxComponent = config.toolboxComponent = {},\n        api,\n        store,\n        composition,\n        saveTo = 'tsObject',\n        requiredParams = [\n          'graphics',\n          'globalReactiveModel',\n          'chart',\n          'spaceManagerInstance',\n          'chartInstance',\n          'smartLabel',\n          'extData',\n          'parentGroup',\n          'lib',\n          function acquire () {\n            let i = 0,\n              ii = requiredParams.length - 1,\n              param = '';\n            self[saveTo] = self[saveTo] || {};\n            self.requiredParams = {};\n            for (i = 0; i < ii; ++i) {\n              param = requiredParams[i];\n              self[saveTo][param] = arguments[i];\n            }\n          }\n        ];\n      require(requiredParams);\n\n      tsObject = self.tsObject;\n      config.usrConfig = tsObject.extData;\n\n      api = tsObject.chartInstance.apiInstance;\n      store = api.getComponentStore();\n      config.composition = composition = store.getCanvasByIndex(0).composition;\n      config.dataAgg = composition.impl.getDataAggregator();\n\n      toolboxComponent.toolbox = dep.FC.getComponent('api', 'toolbox');\n      toolboxComponent.config = {};\n\n      self.toolbars = [];\n\n      self.measurement = {};\n\n      self.toolbars.push(self.createToolbar());\n\n      composition.reactiveModel.onPropsChange(['bin-size', 'aggregation-fn'], function () {\n        if (config.execute) {\n          config.execute = false;\n          setTimeout(() => {\n            self.rangeOnChange();\n          }, 200);\n        }\n      });\n\n      window.Aggregator = self;\n      return self;\n    }\n\n    /**\n     * Create toolbar components\n     * @private\n     */\n    createToolbar () {\n      var self = this,\n        labelGroup,\n        selectMenuGroup,\n        buttonGroup,\n        toolbar,\n        timeMulSelectMenu,\n        timePeriodSelectMenu,\n        aggMethodSelectMenu,\n        resetButton,\n        applyButton,\n        config = self.config,\n        tsObject = self.tsObject,\n        label,\n\n        toolboxComponent = config.toolboxComponent,\n        toolbox = toolboxComponent.toolbox,\n        toolboxCompConfig = toolboxComponent.config,\n        HorizontalToolbar = toolbox.HorizontalToolbar,\n        ComponentGroup = toolbox.ComponentGroup,\n\n        graphics = tsObject.graphics,\n        paper = graphics.paper,\n        d3 = paper.getInstances().d3,\n        container = graphics.container,\n        chart = tsObject.chart,\n        smartLabel = tsObject.smartLabel,\n\n        timeMulSelectMenuOpt,\n\n        usrConfig,\n        style,\n\n        dependencies = {\n          paper: paper,\n          chart: chart,\n          smartLabel: smartLabel,\n          chartContainer: container\n        },\n\n        /**\n         * Sets valid time multiplier on time period change from extension toolbox\n         * @private\n         */\n        timePeriodOnChange = () => {\n          var timePeriodVal = timePeriodSelectMenu.value(),\n            timePeriodMultiplierVal = timeMulSelectMenu.value(),\n            prevTimePeroidMulVal = timePeriodMultiplierVal,\n            validTimePeriod = config.validTimePeriod,\n            validTimePeriodMultiplier = config.validTimePeriodMultiplier,\n            indexOfTimeUnit,\n            indexOfTimeMul,\n            multiplierVal,\n            len,\n            arr,\n            i = 0;\n\n          indexOfTimeUnit = validTimePeriod.indexOf(timePeriodVal);\n          indexOfTimeMul = validTimePeriodMultiplier[indexOfTimeUnit].indexOf(Number(timePeriodMultiplierVal));\n\n          timeMulSelectMenuOpt = [];\n          arr = validTimePeriodMultiplier[indexOfTimeUnit];\n          for (i = 0, len = arr.length; i < len; i++) {\n            multiplierVal = arr[i];\n            timeMulSelectMenuOpt.push({\n              name: multiplierVal.toString(),\n              value: multiplierVal.toString()\n            });\n          }\n\n          timeMulSelectMenu.updateList(timeMulSelectMenuOpt);\n\n          if (indexOfTimeMul < 0) {\n            timeMulSelectMenu.value(validTimePeriodMultiplier[indexOfTimeUnit][0].toString());\n          } else {\n            timeMulSelectMenu.value(prevTimePeroidMulVal);\n          }\n        },\n\n        /**\n         * Sets state of applyButton(active/inactive) on change in value in toolbox\n         * @private\n         */\n        onChange = (type) => {\n          var currentAgg = self.getCurrentAggreation();\n          currentAgg.timePeriodMultiplier = currentAgg.timePeriodMultiplier &&\n            currentAgg.timePeriodMultiplier.toString();\n\n          if (currentAgg.timePeriodMultiplier !== timeMulSelectMenu.value() ||\n            currentAgg.timePeriod !== timePeriodSelectMenu.value() ||\n            currentAgg.aggregationMethod.value !== aggMethodSelectMenu.value()) {\n            applyButton.removeState('disabled');\n          } else {\n            applyButton.setState('disabled');\n          }\n\n          if (!aggMethodSelectMenu.value()) {\n            aggMethodSelectMenu.value(config.defaultAggMethod);\n          }\n          if (!timePeriodSelectMenu.value() && !timeMulSelectMenu.value()) {\n            timePeriodSelectMenu.value(config.validTimePeriod[0]);\n            timePeriodOnChange();\n          }\n        };\n\n      labelGroup = new ComponentGroup(dependencies, {\n        hPadding: 4\n      });\n      selectMenuGroup = new ComponentGroup(dependencies, {\n        hPadding: 0\n      });\n      buttonGroup = new ComponentGroup(dependencies, {\n        hPadding: 0\n      });\n\n      toolbar = new HorizontalToolbar(dependencies);\n      usrConfig = config.usrConfig;\n\n      var selectConf = {\n        container: {\n          style: {\n            'fill': '#fff',\n            'stroke': '#c8cecd',\n            'stroke-width': '1'\n          },\n          states: {\n            selected: {\n              stroke: '#1e1f1f'\n            },\n            hover: {\n              cursor: 'pointer'\n            }\n          }\n        },\n        text: {\n          style: {\n            fill: '#696969',\n            'font-size': '11px',\n            'font-family': '\"Lucida Grande\", sans-serif'\n          }\n        },\n        arrow: {\n          style: {\n            fill: '#696969'\n          }\n        },\n        attrs: {\n          'radius': 2,\n          'width': 50,\n          'height': 22,\n          'margin': {\n            right: 3\n          }\n        }\n      };\n\n      var defaultStyle = {\n        label: {\n          container: {\n            height: 22,\n            style: {\n\n            }\n          },\n          margin: {\n            right: 2\n          },\n          text: {\n            style: {\n              'font-size': '13px',\n              'font-family': '\"Lucida Grande\", sans-serif',\n              'font-weight': 'bold',\n              'fill': '#4b4b4b'\n            }\n          }\n        },\n        timeMulSelectMenu: {\n          container: selectConf.container,\n          text: selectConf.text,\n          arrow: selectConf.arrow,\n          attrs: {\n            'radius': 2,\n            'width': 50,\n            'height': 22,\n            'margin': {\n              right: 3,\n              left: 0\n            },\n            padding: {\n              left: 10,\n              right: 8\n            }\n          },\n          eventListeners: [{\n            type: 'change',\n            cb: onChange\n          }]\n        },\n        timePeriodSelectMenu: {\n          container: selectConf.container,\n          text: selectConf.text,\n          arrow: selectConf.arrow,\n          attrs: {\n            'radius': 2,\n            'width': 90,\n            'height': 22,\n            'margin': {\n              right: 9,\n              left: 0\n            },\n            padding: {\n              left: 10,\n              right: 8\n            }\n          },\n          eventListeners: [{\n            type: 'change',\n            cb: function () {\n              timePeriodOnChange();\n              onChange();\n            }\n          }]\n        },\n        aggMethodSelectMenu: {\n          container: selectConf.container,\n          text: selectConf.text,\n          arrow: selectConf.arrow,\n          attrs: {\n            'radius': 2,\n            'width': 100,\n            'height': 22,\n            margin: {\n              right: 8,\n              left: 0\n            },\n            padding: {\n              left: 10,\n              right: 8\n            }\n          },\n          eventListeners: [{\n            type: 'change',\n            cb: onChange\n          }]\n        },\n        dropDown: {\n          container: {\n            style: {\n              background: '#fff',\n              'border-color': '#898b8b',\n              'border-radius': '1px',\n              'border-style': 'solid',\n              'border-width': '2px',\n              'font-size': '11px',\n              'font-family': '\"Lucida Grande\", sans-serif'\n            }\n          },\n          listItem: {\n            style: {\n            },\n            states: {\n              hover: {\n                className: undefined,\n                style: {\n                  'background': '#e6e8e8',\n                  'color': '#696969',\n                  'cursor': 'pointer'\n                }\n              },\n              selected: {\n                className: undefined,\n                style: {\n                  'background': '#898b8b',\n                  'color': '#fff'\n                }\n              }\n            }\n          }\n        },\n        applyButton: {\n          container: {\n            style: {\n              'fill': '#555',\n              'stroke': '#ced5d4',\n              'stroke-width': 0\n            },\n            states: {\n              disabled: {\n                'fill': '#bebebe',\n                'stroke-width': 0,\n                'stroke': '#ced5d4'\n              },\n              hover: {\n                cursor: 'pointer'\n              }\n            }\n          },\n          text: {\n            style: {\n              'fill': '#f3f3f3',\n              'fontSize': '11px',\n              'fontFamily': '\"Lucida Grande\", sans-serif'\n            },\n            states: {\n              disabled: {\n                'fill': '#f3f3f3'\n              }\n            }\n          },\n          attrs: {\n            'radius': 1,\n            'width': 54,\n            'height': 22,\n            margin: {\n              right: 3,\n              left: 0\n            },\n            label: 'APPLY'\n          },\n          eventListeners: [{\n            type: 'click',\n            cb: function () {\n              self.apply(1);\n            }\n          }]\n        },\n        resetButton: {\n          container: {\n            style: {\n              'fill': '#898b8b',\n              'stroke': '#ced5d4',\n              'strokeWidth': 0\n            },\n            states: {\n              hover: {\n                cursor: 'pointer'\n              },\n              disabled: {\n                'fill': '#bebebe',\n                'stroke-width': 0,\n                'stroke': '#ced5d4',\n                cursor: 'default'\n              }\n            }\n          },\n          text: {\n            style: {\n              fill: '#f3f3f3',\n              'fontSize': '11px',\n              'fontFamily': '\"Lucida Grande\", sans-serif'\n            },\n            states: {\n              disabled: {\n                fill: '#f3f3f3'\n              }\n            }\n          },\n          attrs: {\n            'radius': 1,\n            'shadow': {\n              'fill': '#000',\n              'opacity': 0.35\n            },\n            'width': 54,\n            'height': 22,\n            margin: {\n              right: 3,\n              left: 0\n            },\n            label: 'RESET'\n          },\n          eventListeners: [{\n            type: 'click',\n            cb: function () {\n              self.apply(0);\n            }\n          }]\n        }\n      };\n\n      style = defaultStyle;\n\n      if (usrConfig.styles) {\n        mergeRecursively(usrConfig.styles, defaultStyle, this.tsObject.lib);\n        style = usrConfig.styles;\n      }\n\n      label = new toolbox.Label('Aggregation: ', dependencies, style.label);\n\n      label.setConfig({\n        className: style.label.className\n      });\n\n      applyClassName(label.getIndividualClassNames(label.getClassName()), 'label');\n\n      var parentGroup = tsObject.parentGroup;\n      var count = 0;\n\n      function applyClassName (obj, prop, state) {\n        var _style;\n        for (var key in obj) {\n          if (style[prop][key]) {\n            if (state && style[prop][key].states && style[prop][key].states[state]) {\n              _style = style[prop][key].states[state];\n            } else {\n              _style = style[prop][key].style;\n            }\n          }\n          _style && paper.cssAddRule('.' + obj[key], _style);\n        }\n      }\n\n      function factory (prop, cb, options) {\n        var sm = toolboxCompConfig[prop] = cb(options)\n        .setConfig(style[prop].attrs);\n\n        sm.setParentGroup(parentGroup);\n        sm.setConfig({\n          className: style[prop].className\n        });\n\n        sm.namespace('fusioncharts');\n        sm.appendSelector('ext1-' + (count++));\n\n        applyClassName(sm.getIndividualClassNames(sm.getClassName()), prop);\n        var classNames = sm.config.states;\n        for (var key in classNames) {\n          applyClassName(sm.getIndividualClassNames(classNames[key]), prop, key);\n        }\n\n        var dm = sm.config.dropDownMenu;\n        for (var components in dm) {\n          var component = dm[components];\n          switch (components) {\n            case 'container':\n              paper.cssAddRule('.' + component.className, style.dropDown.container.style);\n              break;\n            case 'listItem':\n              paper.cssAddRule('.' + component.className, style.dropDown.listItem.style);\n              var states = component.states;\n              for (var state in states) {\n                paper.cssAddRule('.' + states[state], style.dropDown.listItem.states[state].style);\n              }\n              break;\n          }\n        }\n\n        var eventListeners = style[prop].eventListeners;\n        for (var i = 0, len = eventListeners.length; i < len; i += 1) {\n          var event = eventListeners[i];\n          var obj = {};\n          obj[event.type] = event.cb;\n          sm.attachEventHandlers(obj);\n        }\n        return sm;\n      }\n\n      function createSelectButton (prop) {\n        return factory(prop, d3.selectButton, []);\n      }\n\n      function createButton (prop) {\n        return factory(prop, d3.button, style[prop].attrs.label);\n      }\n\n      labelGroup.addSymbol(label);\n      labelGroup.setConfig({\n        margin: {\n          right: 0\n        }\n      });\n\n      timeMulSelectMenu = createSelectButton('timeMulSelectMenu');\n      timePeriodSelectMenu = createSelectButton('timePeriodSelectMenu');\n      aggMethodSelectMenu = createSelectButton('aggMethodSelectMenu');\n\n      applyButton = createButton('applyButton');\n      resetButton = createButton('resetButton');\n\n      selectMenuGroup.addSymbol(timeMulSelectMenu);\n      selectMenuGroup.addSymbol(timePeriodSelectMenu);\n      selectMenuGroup.addSymbol(aggMethodSelectMenu);\n      buttonGroup.addSymbol(applyButton);\n      buttonGroup.addSymbol(resetButton);\n\n      toolbar.addComponent(labelGroup);\n      toolbar.addComponent(selectMenuGroup);\n      toolbar.addComponent(buttonGroup);\n      return toolbar;\n    }\n\n    getLogicalSpace (availableWidth, availableHeight) {\n      var logicalSpace,\n        width = 0,\n        height = 0,\n        i,\n        ln;\n\n      for (i = 0, ln = this.toolbars.length; i < ln; i++) {\n        logicalSpace = this.toolbars[i].getLogicalSpace(availableWidth, availableHeight);\n        width = Math.max(logicalSpace.width, width);\n        height += logicalSpace.height;\n        this.toolbars[i].width = logicalSpace.width;\n        this.toolbars[i].height = logicalSpace.height;\n      }\n      height += this.padding;\n      return {\n        width: width,\n        height: height\n      };\n    }\n\n    placeInCanvas (containerInstance) {\n      var self = this,\n        tsObject = self.tsObject,\n        usrConfig = self.config.usrConfig;\n\n      self.padding = 5;\n      tsObject.spaceManagerInstance.add([{\n        name: function () {\n          return 'data-aggregator';\n        },\n        ref: function (obj) {\n          return obj['0'];\n        },\n        self: function () {\n          return self;\n        },\n        priority: function () {\n          return 2;\n        },\n        layout: function (obj) {\n          return obj[usrConfig.layout || 'inline'];\n        },\n        orientation: [{\n          type: function (obj) {\n            return obj[usrConfig.orientation || 'horizontal'];\n          },\n          position: [{\n            type: function (obj) {\n              return obj[usrConfig.position || 'bottom'];\n            },\n            alignment: [{\n              type: function (obj) {\n                return obj[usrConfig.alignment || 'right'];\n              },\n              dimensions: [function () {\n                var parent = this.getParentComponentGroup();\n                return self.getLogicalSpace(parent.getWidth(), parent.getHeight());\n              }]\n            }]\n          }]\n        }]\n      }]);\n    }\n\n    setDrawingConfiguration (x, y, width, height, group) {\n      var mes = this.measurement;\n      mes.x = x;\n      mes.y = y;\n      mes.width = width;\n      mes.height = height;\n\n      this.parentGroup = group;\n\n      return this;\n    }\n\n    /**\n     * Apply or Reset Aggregation applied through extension in timeseries\n     * @param {number} set - Flag to set or reset. '1' to set, '0' to reset\n     * @private\n     */\n    apply (set) {\n      var self = this,\n        config = self.config,\n        toolboxCompConfig = config.toolboxComponent.config,\n        timePeriodSelectMenu = toolboxCompConfig.timePeriodSelectMenu,\n        timeMulSelectMenu = toolboxCompConfig.timeMulSelectMenu,\n        aggMethodSelectMenu = toolboxCompConfig.aggMethodSelectMenu,\n        applyButton = toolboxCompConfig.applyButton,\n        resetButton = toolboxCompConfig.resetButton,\n\n        aggregate = self.tsObject.extData.aggregate || {},\n        validTimePeriod,\n        validTimePeriodMultiplier,\n        avlAggMethods,\n\n        indexOfTimeUnit,\n        validTimeBin,\n        validMethod,\n\n        model = config.composition.reactiveModel,\n        timePeriodVal,\n        timePeriodMultiplierVal,\n        aggMethod,\n        keys,\n        binSize,\n        timeInterval,\n        aggregation = self.aggregation,\n        arr,\n        i,\n        len,\n        canvas = config.composition.impl;\n\n      if (set) {\n        if (!config.drawn) {\n          timePeriodVal = aggregate.timeUnit && aggregate.timeUnit.toString().toLowerCase();\n          timePeriodMultiplierVal = aggregate.timeMultiplier;\n          aggMethod = aggregate.method && aggregate.method.toString();\n\n          self.getValidAggregation();\n          validTimePeriod = config.validTimePeriod;\n          validTimePeriodMultiplier = config.validTimePeriodMultiplier;\n          avlAggMethods = config.avlAggMethods;\n\n          if (validTimePeriod.includes(timePeriodVal)) {\n            indexOfTimeUnit = validTimePeriod.indexOf(timePeriodVal);\n            if (!validTimePeriodMultiplier[indexOfTimeUnit].includes(Number(timePeriodMultiplierVal))) {\n              timePeriodMultiplierVal = validTimePeriodMultiplier[indexOfTimeUnit][0];\n            }\n            validTimeBin = true;\n          }\n\n          if (avlAggMethods[aggMethod]) {\n            validMethod = true;\n          }\n\n          if (validTimeBin || validMethod) {\n            if (validTimeBin) {\n              arr = config.avlTimePeriods;\n              for (i = 0, len = arr.length; i < len; i++) {\n                keys = arr[i];\n                if (keys.name === timePeriodVal) {\n                  timeInterval = keys.interval;\n                  break;\n                }\n              }\n              binSize = timeInterval * Number(timePeriodMultiplierVal);\n              model\n                .lock()\n                .prop('bin-size-ext', binSize)\n                .unlock();\n              aggregation.binSize = binSize;\n            }\n\n            if (validMethod) {\n              model\n                .lock()\n                .prop('aggregation-fn-ext', config.avlAggMethods[aggMethod])\n                .unlock();\n              aggregation.aggregationMethod = aggMethod;\n            }\n            applyButton.setState('disabled');\n            resetButton.removeState('disabled');\n          }\n        } else {\n          timePeriodVal = timePeriodSelectMenu.value();\n          timePeriodMultiplierVal = timeMulSelectMenu.value();\n          aggMethod = aggMethodSelectMenu.value();\n          arr = config.avlTimePeriods;\n          for (i = 0, len = arr.length; i < len; i++) {\n            keys = arr[i];\n            if (keys.name === timePeriodVal) {\n              timeInterval = keys.interval;\n              break;\n            }\n          }\n          binSize = timeInterval * Number(timePeriodMultiplierVal);\n          model\n            .lock()\n            .prop('bin-size-ext', binSize)\n            .prop('aggregation-fn-ext', config.avlAggMethods[aggMethod])\n            .unlock();\n          aggregation.binSize = binSize;\n          aggregation.aggregationMethod = aggMethod;\n          applyButton.setState('disabled');\n          resetButton.removeState('disabled');\n        }\n      } else {\n        canvas.resetAggregation();\n        aggregation.binSize = null;\n        aggregation.aggregationMethod = null;\n        resetButton.setState('disabled');\n      }\n    }\n\n    /**\n     * Compute and populate toolboxes with valid values on change in range of visual window\n     * @private\n     */\n    rangeOnChange () {\n      var self = this,\n        config = self.config,\n        toolboxCompConfig = config.toolboxComponent.config,\n        timePeriodSelectMenu = toolboxCompConfig.timePeriodSelectMenu,\n        timeMulSelectMenu = toolboxCompConfig.timeMulSelectMenu,\n        aggMethodSelectMenu = toolboxCompConfig.aggMethodSelectMenu,\n        applyButton = toolboxCompConfig.applyButton,\n        resetButton = toolboxCompConfig.resetButton,\n        model = config.composition.reactiveModel,\n\n        timePeriodVal,\n        timePeriodSelectMenuOpt,\n        validTimePeriod,\n        indexOfTimeUnit,\n\n        multiplierVal,\n        timeMulSelectMenuOpt,\n        validTimePeriodMultiplier,\n\n        aggVal,\n        aggMethodSelectMenuOpt,\n        avlAggMethods,\n\n        aggregation = self.aggregation,\n        currentAggregationObj,\n        timePeriod,\n        timePeriodMultiplier,\n        aggregationMethod,\n        i,\n        len,\n        arr;\n\n      self.getValidAggregation();\n      currentAggregationObj = self.getCurrentAggreation();\n      timePeriod = currentAggregationObj.timePeriod;\n      timePeriodMultiplier = currentAggregationObj.timePeriodMultiplier;\n      aggregationMethod = currentAggregationObj.aggregationMethod;\n\n      timePeriodSelectMenuOpt = [];\n      timeMulSelectMenuOpt = [];\n      aggMethodSelectMenuOpt = [];\n\n      validTimePeriod = config.validTimePeriod;\n      validTimePeriodMultiplier = config.validTimePeriodMultiplier;\n      avlAggMethods = config.avlAggMethods;\n\n      applyButton.setState('disabled');\n\n      if (aggregation.binSize !== model.prop('bin-size') &&\n        (aggregationMethod.value === config.defaultAggMethod || !aggregationMethod.value)) {\n        aggregation.binSize = null;\n        aggregation.aggregationMethod = null;\n        resetButton.setState('disabled');\n      } else {\n        resetButton.removeState('disabled');\n      }\n\n      for (i = 0, len = validTimePeriod.length; i < len; i++) {\n        timePeriodVal = validTimePeriod[i];\n        timePeriodSelectMenuOpt.push({\n          name: capitalize(timePeriodVal),\n          value: timePeriodVal\n        });\n      }\n\n      timePeriodSelectMenu.updateList(timePeriodSelectMenuOpt);\n      timePeriod ? timePeriodSelectMenu.value(timePeriod) : timePeriodSelectMenu.setPlaceHolderValue('');\n\n      indexOfTimeUnit = validTimePeriod.indexOf(timePeriod);\n\n      if (indexOfTimeUnit >= 0) {\n        arr = validTimePeriodMultiplier[indexOfTimeUnit];\n        for (i = 0, len = arr.length; i < len; i++) {\n          multiplierVal = arr[i];\n          timeMulSelectMenuOpt.push({\n            name: multiplierVal.toString(),\n            value: multiplierVal.toString()\n          });\n        }\n      }\n\n      timeMulSelectMenu.updateList(timeMulSelectMenuOpt);\n      timePeriodMultiplier ? timeMulSelectMenu.value(timePeriodMultiplier.toString())\n        : timeMulSelectMenu.setPlaceHolderValue('');\n\n      for (aggVal in avlAggMethods) {\n        aggMethodSelectMenuOpt.push({\n          name: capitalize(avlAggMethods[aggVal].formalName),\n          value: avlAggMethods[aggVal].nickName\n        });\n      }\n\n      aggMethodSelectMenu.updateList(aggMethodSelectMenuOpt);\n      aggregationMethod.value ? aggMethodSelectMenu.value(aggregationMethod.value)\n        : aggMethodSelectMenu.setPlaceHolderValue('');\n      config.execute = true;\n    }\n\n    draw (x, y, width, height, group) {\n      var self = this,\n        config = self.config,\n        measurement = self.measurement,\n        toolbars = self.toolbars,\n        ln,\n        i,\n        toolbar,\n        dataAgg = config.dataAgg;\n\n      self.getAvailablelAggreagation();\n\n      x = x === undefined ? measurement.x : x;\n      y = y === undefined ? measurement.y : y;\n      width = width === undefined ? measurement.width : width;\n      height = height === undefined ? measurement.height : height;\n      group = group === undefined ? self.parentGroup : group;\n      if (width && height) {\n        for (i = 0, ln = toolbars.length; i < ln; i++) {\n          toolbar = toolbars[i];\n          toolbar.draw(x, y, group);\n        }\n\n        config.defaultAggMethod = dataAgg.getDefaultAggregationMethod().nickName;\n        !config.drawn && self.apply(1);\n        self.rangeOnChange();\n        config.drawn = true;\n      }\n    }\n\n    dispose () {\n      // dispose extension\n    }\n  }\n  return Aggregator;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/data-aggregator-ext.js\n// module id = 1\n// module chunks = 0"],"sourceRoot":""}